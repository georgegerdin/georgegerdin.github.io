<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple 3D Block Game (Three.js) - Improved Collision & Face Outline</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #7ec0ee; }
        canvas { display: block; }
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex; /* Use flexbox */
            justify-content: center; /* Center horizontally */
            align-items: center; /* Center vertically */
        }
        #instructions {
            width: 60%;
            background-color: #fff;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
        }
        #crosshair {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 10px; /* Adjusted size */
            height: 1px; /* Line crosshair - horizontal */
            background-color: white;
            transform: translate(-50%, -50%);
            pointer-events: none; /* Don't let it interfere with clicks */
            mix-blend-mode: difference; /* Makes it visible on most backgrounds */
        }
        /* Vertical line for the crosshair */
        #crosshair::after {
            content: '';
            position: absolute;
            left: 50%;
            top: -4.5px; /* Position relative to parent */
            width: 1px;
            height: 10px; /* Match parent width */
            background-color: white;
            transform: translateX(-50%);
            mix-blend-mode: difference;
        }
         #toolbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            background-color: rgba(200, 200, 200, 0.8);
            padding: 5px;
            border-radius: 5px;
            border: 1px solid #555;
            z-index: 10; /* Ensure it's above the canvas */
         }
        .tool-button {
            width: 40px;
            height: 40px;
            border: 2px solid #555;
            cursor: pointer;
            background-size: cover; /* Scale texture nicely */
            image-rendering: pixelated; /* Keep textures blocky */
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            transition: transform 0.1s ease-out, border 0.1s ease-out; /* Smooth transitions */
        }
        .tool-button.selected {
            border: 3px solid #0000ff; /* Blue border for selection */
            transform: scale(1.1); /* Slightly larger when selected */
            box-shadow: 0 0 5px rgba(0, 0, 255, 0.7); /* Optional glow */
        }
        /* Info Display Styles */
        #infoDisplay {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 8px;
            border-radius: 5px;
            font-family: monospace; /* Good for aligning numbers */
            font-size: 12px;
            line-height: 1.4;
            z-index: 5; /* Above canvas, below blocker maybe */
            pointer-events: none; /* Don't capture mouse clicks */
        }
        #infoDisplay span {
            display: inline-block; /* Allows setting width */
            min-width: 35px;      /* Keeps layout stable */
            text-align: right;    /* Align numbers nicely */
            margin-left: 2px;
        }
    </style>
</head>
<body>
    <div id="blocker">
        <div id="instructions">
            <h1>Simple 3D Blocks</h1>
            <p>Click to Play</p>
            <p>(W, A, S, D = Move, SPACE = Jump, MOUSE = Look)</p>
            <p>Left Click = Place Block, Right Click = Remove Block</p>
            <p>SCROLL WHEEL = Change Block Type</p>
             <p style="color: green;">Strafing Fixed & Face Outline Added!</p>
        </div>
    </div>

    <div id="crosshair"></div>

    <div id="toolbar">
        <!-- Tool buttons will be populated by JS -->
    </div>

    <!-- Info Display -->
    <div id="infoDisplay">
        <div>FPS:<span id="fpsValue">--</span></div>
        <div>Pos:
            X:<span id="posX">--.--</span>|
            Y:<span id="posY">--.--</span>|
            Z:<span id="posZ">--.--</span>
        </div>
        <div>View:
            Yaw:<span id="viewYaw">--.--</span>°|
            Pitch:<span id="viewPitch">--.--</span>°
        </div>
    </div>

    <!-- Import three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                 "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        let scene, camera, renderer, controls;
        let world = {};
        const objects = []; // Holds meshes for raycasting (blocks)

        const worldWidth = 20;
        const worldDepth = 20;
        const worldHeight = 10; // Max build height
        const groundHeight = 5; // Initial ground level

        // Movement states
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let moveDown = false; // Keep variable but currently disabled in key handlers
        let canJump = false; // Track if player is on ground

        // Physics/Movement variables
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const gravity = 30.0;
        const jumpVelocity = 10.0;
        const playerSpeed = 400.0; // Scaled by delta in movement calculation
        const playerHeight = 1.8; // How tall the player is (eye level to feet)
        const playerWidth = 0.6; // Player bounding box width/depth (less than 1 block)
        const playerHalfWidth = playerWidth / 2;
        const playerHalfDepth = playerWidth / 2; // Assuming square base for simplicity

        // DOM Elements
        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');
        const toolbar = document.getElementById('toolbar');
        let fpsValueSpan, posXSpan, posYSpan, posZSpan, viewYawSpan, viewPitchSpan; // For info display

        // --- Tool Management ---
        const textureUrls = { // URLs for TOOLBAR ICONS (and some mesh textures)
            grass: 'grass.jpg', // Use top view for grass icon
            dirt: 'dirt.jpg',
            stone: 'cobble.jpg',
            wood: 'wood.jpg', // Use top view for wood icon
            leaves: 'leaves.webp',
            sand: 'sand.jpg',
        };
        const toolTypes = Object.keys(textureUrls); // Defines order of tools
        let currentToolIndex = 0; // Start with the first tool
        let currentTool = toolTypes[currentToolIndex]; // Initialize currentTool based on index

        // --- Texture Loading (for 3D Meshes) ---
        const textureLoader = new THREE.TextureLoader();
        const textures = {
            dirt: textureLoader.load(textureUrls.dirt), // Reuse URL
            grass: textureLoader.load('grass.jpg'), // Side texture for mesh (assuming different file or same if side/top same)
            grass_top: textureLoader.load(textureUrls.grass), // Top texture for mesh & icon
            stone: textureLoader.load(textureUrls.stone),
            wood: textureLoader.load('wood.jpg'), // Side texture for mesh
            wood_top: textureLoader.load(textureUrls.wood), // Top texture for mesh & icon
            leaves: textureLoader.load(textureUrls.leaves),
            sand: textureLoader.load(textureUrls.sand),
        };

        // Improve texture appearance (pixelated)
        for (const key in textures) {
            if (textures[key] && textures[key] instanceof THREE.Texture) {
                textures[key].magFilter = THREE.NearestFilter;
                textures[key].minFilter = THREE.NearestFilter;
            }
        }

        // --- Material Definitions ---
         const materials = {
            grass: [ // Multi-material for different faces
                new THREE.MeshLambertMaterial({ map: textures.grass }), // right (+x)
                new THREE.MeshLambertMaterial({ map: textures.grass }), // left (-x)
                new THREE.MeshLambertMaterial({ map: textures.grass_top }), // top (+y)
                new THREE.MeshLambertMaterial({ map: textures.dirt }),    // bottom (-y)
                new THREE.MeshLambertMaterial({ map: textures.grass }), // front (+z)
                new THREE.MeshLambertMaterial({ map: textures.grass }), // back (-z)
            ],
            dirt: new THREE.MeshLambertMaterial({ map: textures.dirt }),
            stone: new THREE.MeshLambertMaterial({ map: textures.stone }),
            wood: [ // Multi-material for logs
                 new THREE.MeshLambertMaterial({ map: textures.wood }), // right
                 new THREE.MeshLambertMaterial({ map: textures.wood }), // left
                 new THREE.MeshLambertMaterial({ map: textures.wood_top }), // top
                 new THREE.MeshLambertMaterial({ map: textures.wood_top }), // bottom
                 new THREE.MeshLambertMaterial({ map: textures.wood }), // front
                 new THREE.MeshLambertMaterial({ map: textures.wood }), // back
            ],
            leaves: new THREE.MeshLambertMaterial({
                 map: textures.leaves,
                 alphaTest: 0.5, // Simple cutout transparency
                 side: THREE.DoubleSide // Render both sides
                }),
            sand: new THREE.MeshLambertMaterial({ map: textures.sand }),
        };


        // --- Raycasting (for block interaction) ---
        const raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, 0, -1), 0, 5); // Limit raycast distance
        const pointer = new THREE.Vector2(0, 0); // Center of screen for raycasting

        // --- Face Outline ---
        const faceOutlineGeometry = new THREE.PlaneGeometry(1, 1); // Size of a block face
        // Make it yellow, slightly transparent, render on top slightly
        const faceOutlineMaterial = new THREE.MeshBasicMaterial({
            color: 0xffff00, // Yellow
            side: THREE.DoubleSide, // Visible from both sides
            transparent: true,
            opacity: 0.4,
            depthTest: false // Render on top (helps avoid z-fighting)
        });
        const faceOutlineMesh = new THREE.Mesh(faceOutlineGeometry, faceOutlineMaterial);
        faceOutlineMesh.visible = false; // Start hidden

        // Timing
        let prevTime = performance.now();
        let lastInfoUpdateTime = 0; // Can be used to throttle info updates if needed

        init();
        animate();

        // --- Utility Functions ---
        function getVoxelKey(x, y, z) {
             return `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`;
        }

        // Gets the correct material (single or array) for a block type
        function getMaterial(type) {
             if (type === 'grass') return materials.grass;
             if (type === 'wood') return materials.wood;
             // For single-texture blocks or fallback
             return materials[type] || materials.stone; // Default to stone if specific material undefined
        }


        // --- Voxel Management ---
        function addVoxel(x, y, z, type) {
            x = Math.floor(x); // Ensure integer coordinates
            y = Math.floor(y);
            z = Math.floor(z);
            const key = getVoxelKey(x, y, z);

            // Prevent building outside world bounds or overwriting existing blocks
            if (world[key] || y < 0 || y >= worldHeight) return;

             // Ensure material exists for the type before creating mesh
             let material = getMaterial(type);
             if (!material) {
                 console.warn(`No material found for type: ${type}. Using stone.`);
                 type = 'stone'; // Fallback to stone if material is missing
                 material = materials.stone;
             }

            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const mesh = new THREE.Mesh(geometry, material);

            // Position mesh at the center of the voxel space
            mesh.position.set(x + 0.5, y + 0.5, z + 0.5);
            // Store voxel coordinates and type in userData for later retrieval
            mesh.userData = { x, y, z, type };

            scene.add(mesh);
            objects.push(mesh); // Add to raycasting list
            world[key] = { type: type, mesh: mesh }; // Add to world dictionary
        }

         function removeVoxel(x, y, z) {
            x = Math.floor(x);
            y = Math.floor(y);
            z = Math.floor(z);
            const key = getVoxelKey(x, y, z);
            const voxelData = world[key];

            if (voxelData) {
                scene.remove(voxelData.mesh);
                const index = objects.indexOf(voxelData.mesh);
                if (index > -1) {
                    objects.splice(index, 1); // Remove from raycasting list
                }
                 // Optional: Dispose geometry/material if concerned about memory leaks
                 // voxelData.mesh.geometry.dispose();
                 // (material disposal is more complex if it's an array)
                delete world[key]; // Remove from world dictionary
                return true; // Indicate success
            }
            return false; // Indicate nothing was removed
        }

        // --- World Generation ---
        function generateWorld() {
            // Simple flat world base
            for (let x = -worldWidth / 2; x < worldWidth / 2; x++) {
                for (let z = -worldDepth / 2; z < worldDepth / 2; z++) {
                    for (let y = 0; y < groundHeight; y++) {
                        let type = 'stone';
                         if (y === groundHeight - 1) type = 'grass'; // Top layer grass
                         else if (y >= groundHeight - 3) type = 'dirt'; // Dirt below grass
                         addVoxel(x, y, z, type);
                    }
                }
            }
             // Add simple "trees"
            for (let i = 0; i < 5; i++) { // Add 5 trees
                const treeX = Math.floor(Math.random() * worldWidth - worldWidth / 2);
                const treeZ = Math.floor(Math.random() * worldDepth - worldDepth / 2);
                const treeHeight = 4 + Math.floor(Math.random() * 3); // Random height 4-6 blocks
                const groundKey = getVoxelKey(treeX, groundHeight - 1, treeZ);

                 // Only place tree if the base block is grass
                 if (world[groundKey] && world[groundKey].type === 'grass') {
                     // Trunk
                     for(let y = groundHeight; y < groundHeight + treeHeight; y++) {
                         addVoxel(treeX, y, treeZ, 'wood');
                     }
                     // Leaves (simple cube cluster)
                    const leavesY = groundHeight + treeHeight; // Base Y level for leaves
                    for(let lx = -2; lx <= 2; lx++) { // Iterate in a 5x5 horizontal area
                        for(let lz = -2; lz <= 2; lz++) {
                            for(let ly = 0; ly <= 2; ly++) { // Iterate 3 blocks high
                                // Pruning some leaves for a more rounded shape
                                if (Math.abs(lx) === 2 && Math.abs(lz) === 2) continue; // Skip corners of outer layer
                                if (ly === 2 && (Math.abs(lx) > 1 || Math.abs(lz) > 1)) continue; // Skip outer edges of top layer

                                const currentY = leavesY + ly;
                                const currentX = treeX + lx;
                                const currentZ = treeZ + lz;

                                // Skip the very center bottom block (where trunk ends)
                                if (lx === 0 && lz === 0 && ly < 1) continue;

                                const key = getVoxelKey(currentX, currentY, currentZ);
                                if (!world[key]) { // Only place leaves in empty air blocks
                                     addVoxel(currentX, currentY, currentZ, 'leaves');
                                }
                            }
                        }
                    }
                 }
            }
        }

        // --- Toolbar UI Management ---
        // Updates the visual selection highlight on the toolbar
        function updateToolbarSelection() {
            document.querySelectorAll('#toolbar .tool-button').forEach(btn => {
                btn.classList.remove('selected'); // Remove selected from all
            });
            const selectedButton = document.getElementById(`tool-${currentTool}`);
            if (selectedButton) {
                selectedButton.classList.add('selected'); // Add selected to the current one
            } else {
                 console.error(`Toolbar button not found for type: ${currentTool}`);
            }
        }

        // Creates the toolbar buttons based on toolTypes
        function setupToolbar() {
            toolTypes.forEach(type => {
                const url = textureUrls[type];
                const button = document.createElement('div');
                button.id = `tool-${type}`;
                button.classList.add('tool-button');
                button.dataset.type = type; // Store type for click handler

                if (url) {
                    // Use placeholder images if actual textures aren't available locally
                    // Replace these with actual paths if you have the images
                    const placeholderBase = 'https://via.placeholder.com/40/';
                    const colors = { grass: '009900', dirt: '8B4513', stone: '808080', wood: 'A0522D', leaves: '228B22', sand: 'F4A460' };
                    button.style.backgroundImage = `url(${placeholderBase}${colors[type] || 'CCCCCC'}?text=${type.substring(0,1).toUpperCase()})`; // Simple fallback
                    // For local files (if they exist in the same folder):
                    // button.style.backgroundImage = `url(${url})`;
                } else {
                    // Fallback visual cue if URL is missing
                    button.style.backgroundColor = '#ff00ff'; // Bright pink
                    console.warn(`Missing texture URL for toolbar type: ${type}`);
                }

                // Add click listener to select the tool
                button.addEventListener('click', () => {
                    currentTool = type; // Update tool name
                    currentToolIndex = toolTypes.indexOf(type); // Update index
                    updateToolbarSelection(); // Update visual highlight
                });

                toolbar.appendChild(button); // Add the button to the toolbar div
            });

            // Set initial selection visually after creating all buttons
            updateToolbarSelection();
        }


        // --- Player AABB Helper ---
        function getPlayerAABB(position) {
            // position.y is the eye level, feet are at position.y - playerHeight
            return new THREE.Box3(
                new THREE.Vector3(position.x - playerHalfWidth, position.y - playerHeight, position.z - playerHalfDepth),
                new THREE.Vector3(position.x + playerHalfWidth, position.y,                position.z + playerHalfDepth)
            );
        }

        // --- Collision Check Function ---
        function checkCollision(playerPos) {
            const playerAABB = getPlayerAABB(playerPos);
            // Determine the range of world voxels the player AABB *might* overlap with
            const minX = Math.floor(playerAABB.min.x);
            const maxX = Math.floor(playerAABB.max.x);
            const minY = Math.floor(playerAABB.min.y);
            const maxY = Math.floor(playerAABB.max.y);
            const minZ = Math.floor(playerAABB.min.z);
            const maxZ = Math.floor(playerAABB.max.z);

            // Iterate only through the potentially overlapping voxels
            for (let x = minX; x <= maxX; x++) {
                for (let y = minY; y <= maxY; y++) {
                    for (let z = minZ; z <= maxZ; z++) {
                        const key = getVoxelKey(x, y, z);
                        if (world[key]) {
                            // Create a bounding box for the world block
                            const blockAABB = new THREE.Box3(
                                new THREE.Vector3(x, y, z),
                                new THREE.Vector3(x + 1, y + 1, z + 1)
                            );
                            // Check if the player's AABB actually intersects this block's AABB
                            if (playerAABB.intersectsBox(blockAABB)) {
                                return true; // Collision detected
                            }
                        }
                    }
                }
            }
            return false; // No collision found within the potential range
        }


        // --- Initialization Function ---
        function init() {
            // --- Scene ---
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb); // Sky blue
            scene.fog = new THREE.Fog(0x87ceeb, 10, 90); // Fog matches background

            // --- Camera ---
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100); // Near/Far planes
            // Start player slightly higher to avoid initial ground collision issues
            camera.position.set(0, groundHeight + playerHeight + 0.5, 5);

            // --- Renderer ---
            renderer = new THREE.WebGLRenderer({ antialias: false }); // Set true for smoother edges (potential performance cost)
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio); // Adjust for high-DPI screens
            document.body.appendChild(renderer.domElement);

            // --- Lighting ---
            const ambientLight = new THREE.AmbientLight(0xcccccc, 0.9); // Soft ambient light
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // Sun light
            directionalLight.position.set(50, 80, 40); // Angle the sun
            scene.add(directionalLight);

             // --- Controls (Pointer Lock) ---
            controls = new PointerLockControls(camera, document.body);
            scene.add(controls.getObject()); // Add the controls object (which contains the camera) to the scene

            // Lock pointer on instruction click
            instructions.addEventListener('click', () => controls.lock());

            // Handle locking/unlocking the cursor
            controls.addEventListener('lock', () => {
                instructions.style.display = 'none';
                blocker.style.display = 'none';
            });
            controls.addEventListener('unlock', () => {
                blocker.style.display = 'flex'; // Use flex to keep centering
                instructions.style.display = ''; // Show instructions again
            });

             // --- Keyboard Input ---
            const onKeyDown = (event) => {
                 if (event.repeat) return; // Prevent holding key triggering multiple jumps etc.
                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = true; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                    case 'ArrowRight': case 'KeyD': moveRight = true; break;
                    case 'Space':
                         if (canJump) { // Use the canJump flag set by physics
                             velocity.y = jumpVelocity;
                             canJump = false; // Prevent double jump until next ground contact
                         }
                         break;
                    // case 'ShiftLeft': case 'ControlLeft': moveDown = true; break; // Disabled for now
                }
            };
             const onKeyUp = (event) => {
                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = false; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                    case 'ArrowRight': case 'KeyD': moveRight = false; break;
                    // case 'ShiftLeft': case 'ControlLeft': moveDown = false; break; // Disabled for now
                }
            };
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);


            // --- Mouse Input (Block Placement/Removal) ---
             window.addEventListener('mousedown', (event) => {
                 if (!controls.isLocked) return; // Only interact when playing
                 const intersection = getIntersection();
                 if (!intersection) return; // No block intersected

                 const obj = intersection.object;
                 const hitCoords = obj.userData; // Get {x, y, z} of the clicked block

                 // Ensure we clicked a valid world block with coordinates
                 if (!hitCoords || typeof hitCoords.x === 'undefined') {
                     console.log("Clicked on non-world object or object missing coords.");
                     return;
                 }

                 const normal = intersection.face.normal.clone(); // Use the normal of the face clicked

                 if (event.button === 0) { // Left click - Place block
                     // Calculate integer coords of the adjacent voxel using the face normal
                     const placeCoords = {
                         x: hitCoords.x + normal.x,
                         y: hitCoords.y + normal.y,
                         z: hitCoords.z + normal.z
                     };

                     // --- Player Collision Check (using AABB) ---
                     // Create an AABB for the block we intend to place
                     const blockAABB = new THREE.Box3(
                         new THREE.Vector3(placeCoords.x, placeCoords.y, placeCoords.z),
                         new THREE.Vector3(placeCoords.x + 1, placeCoords.y + 1, placeCoords.z + 1)
                     );
                     // Get the player's current AABB
                     const playerAABB = getPlayerAABB(controls.getObject().position);

                     // Check if the new block would intersect the player
                     if (!playerAABB.intersectsBox(blockAABB)) {
                         addVoxel(placeCoords.x, placeCoords.y, placeCoords.z, currentTool);
                     } else {
                         console.log("Cannot place block inside player");
                         // Maybe provide user feedback here? Sound effect? Message?
                     }

                 } else if (event.button === 2) { // Right click - Remove block
                    // Remove the block that was clicked
                    removeVoxel(hitCoords.x, hitCoords.y, hitCoords.z);
                 }
             });

            // --- Scroll Wheel Input (Tool Switching) ---
            window.addEventListener('wheel', (event) => {
                if (!controls.isLocked) return; // Only change tool when playing

                event.preventDefault(); // Prevent page scrolling

                const scrollDirection = Math.sign(event.deltaY); // +1 for down/forward, -1 for up/backward

                if (scrollDirection > 0) { // Scroll down -> next tool
                    currentToolIndex++;
                    if (currentToolIndex >= toolTypes.length) {
                        currentToolIndex = 0; // Wrap around to the start
                    }
                } else if (scrollDirection < 0) { // Scroll up -> previous tool
                    currentToolIndex--;
                    if (currentToolIndex < 0) {
                        currentToolIndex = toolTypes.length - 1; // Wrap around to the end
                    }
                }

                currentTool = toolTypes[currentToolIndex]; // Update tool name
                updateToolbarSelection(); // Update toolbar highlight

            }, { passive: false }); // Required for preventDefault() on wheel events


            // --- Get References to Info Display Elements ---
            fpsValueSpan = document.getElementById('fpsValue');
            posXSpan = document.getElementById('posX');
            posYSpan = document.getElementById('posY');
            posZSpan = document.getElementById('posZ');
            viewYawSpan = document.getElementById('viewYaw');
            viewPitchSpan = document.getElementById('viewPitch');

            // --- World Generation & UI Setup ---
            generateWorld();
            setupToolbar(); // Create toolbar buttons

            // --- Add Face Outline to Scene ---
            scene.add(faceOutlineMesh);

            // --- Window Resize Listener ---
            window.addEventListener('resize', onWindowResize);
        }

        // --- Resize Handler ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Raycasting Function ---
         function getIntersection() {
            raycaster.setFromCamera(pointer, camera); // Cast ray from camera center
            const intersects = raycaster.intersectObjects(objects, false); // Check against block meshes

             // Filter out the outline mesh itself if it somehow gets intersected
             const validIntersects = intersects.filter(intersect => intersect.object !== faceOutlineMesh); // <-- Use new mesh name

             return validIntersects.length > 0 ? validIntersects[0] : null; // Return closest valid intersection
         }

        // --- Update Voxel Face Outline Position/Visibility/Orientation ---
        function updateVoxelOutline() {
             const intersection = getIntersection();

             // Check if we hit a valid block with coordinates and face info
             if (intersection && intersection.object.userData && typeof intersection.object.userData.x !== 'undefined' && intersection.face) {
                const blockCenter = intersection.object.position; // Center position of the hit block
                const faceNormal = intersection.face.normal.clone(); // Get the normal of the *specific* face hit (clone it!)

                // Calculate position for the outline plane:
                // Start at block center, move half a block distance along the normal, plus a tiny offset to avoid z-fighting.
                const outlinePosition = blockCenter.clone().addScaledVector(faceNormal, 0.501); // 0.5 + tiny offset
                faceOutlineMesh.position.copy(outlinePosition);

                // Orient the plane to face outwards, aligned with the face normal:
                // We can make the plane 'lookAt' a point slightly further along the normal vector.
                const lookAtTarget = outlinePosition.clone().add(faceNormal); // Point away from the center along the normal
                faceOutlineMesh.lookAt(lookAtTarget);

                faceOutlineMesh.visible = true;
             } else {
                 faceOutlineMesh.visible = false; // Hide if not looking at a valid block face
             }
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate); // Schedule next frame
            const time = performance.now();
            // Calculate delta time, clamp to prevent large jumps on lag/pause
            const delta = Math.max(0.0001, Math.min(0.05, (time - prevTime) / 1000));
            prevTime = time; // Update prevTime for next frame

            // --- Calculate and Display Info ---
            // Throttle info updates slightly if needed (e.g., every 100ms)
            // if (time - lastInfoUpdateTime > 100) {
                const fps = 1 / delta;
                const playerPos = controls.getObject().position;
                const playerRot = controls.getObject().rotation; // Euler angles (YXZ order)

                const yawDeg = THREE.MathUtils.radToDeg(playerRot.y);
                const pitchDeg = THREE.MathUtils.radToDeg(playerRot.x);

                // Check if elements exist before updating (good practice)
                if (fpsValueSpan) fpsValueSpan.textContent = Math.round(fps);
                if (posXSpan) posXSpan.textContent = playerPos.x.toFixed(2);
                if (posYSpan) posYSpan.textContent = playerPos.y.toFixed(2);
                if (posZSpan) posZSpan.textContent = playerPos.z.toFixed(2);
                // Display yaw wrapped 0-360
                if (viewYawSpan) viewYawSpan.textContent = ((yawDeg % 360 + 360) % 360).toFixed(1);
                if (viewPitchSpan) viewPitchSpan.textContent = pitchDeg.toFixed(1);
                // lastInfoUpdateTime = time;
            // }
            // --- End Info Display Update ---


             if (controls.isLocked) { // Only update physics and interactions if game is active
                const playerPos = controls.getObject().position;

                // --- Apply Damping & Gravity ---
                // Air resistance / friction applied only to X/Z, not Y (gravity handles Y)
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                // Apply gravity
                velocity.y -= gravity * delta;

                // --- Calculate Movement Intent based on Input (RELATIVE TO CAMERA) ---
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                // Don't normalize here if you want diagonal movement to be faster (Minecraft style)
                // Or normalize if you want consistent speed in all directions:
                // direction.normalize(); // Uncomment for consistent diagonal speed

                // Get camera's forward and right vectors (projected onto XZ plane)
                const cameraDirection = new THREE.Vector3();
                controls.getObject().getWorldDirection(cameraDirection); // Use controls object
                const forward = new THREE.Vector3(cameraDirection.x, 0, cameraDirection.z).normalize();
                const right = new THREE.Vector3();
                // Use camera.up which is typically (0, 1, 0) for world up
                // *** STRAFING FIX: Swapped order of cross product ***
                right.crossVectors(forward, camera.up).normalize(); // Calculate right vector

                const currentSpeed = playerSpeed * delta; // Scale speed by frame time

                // Calculate desired velocity change based on input and camera direction
                let velocityChangeX = 0;
                let velocityChangeZ = 0;

                if (direction.z !== 0) { // Forward/Backward input
                    velocityChangeX += forward.x * direction.z * currentSpeed;
                    velocityChangeZ += forward.z * direction.z * currentSpeed;
                }
                if (direction.x !== 0) { // Left/Right input
                     // Note: Cross product gives right vector, so moving 'right' (positive x input) adds velocity along 'right'
                     // Moving 'left' (negative x input) subtracts velocity along 'right' (or adds along negative right)
                    velocityChangeX += right.x * direction.x * currentSpeed;
                    velocityChangeZ += right.z * direction.x * currentSpeed;
                }

                // Apply the calculated velocity changes
                velocity.x += velocityChangeX;
                velocity.z += velocityChangeZ;


                // --- Collision Detection & Resolution (Axis-by-Axis AABB) ---

                // Calculate potential next position based on current velocity and delta time
                let deltaPosX = velocity.x * delta;
                let deltaPosY = velocity.y * delta;
                let deltaPosZ = velocity.z * delta;

                // Use a temporary position vector for checks
                let tempPos = playerPos.clone();

                // --- 1. Resolve X-axis Collision ---
                tempPos.x += deltaPosX; // Check intended X position
                if (checkCollision(tempPos)) {
                    // Collision detected on X axis. Stop X movement.
                    velocity.x = 0;
                    deltaPosX = 0; // Don't apply X movement this frame
                }
                tempPos.x = playerPos.x; // Reset temp position X for next check

                // --- 2. Resolve Z-axis Collision ---
                tempPos.z += deltaPosZ; // Check intended Z position
                if (checkCollision(tempPos)) {
                    // Collision detected on Z axis. Stop Z movement.
                    velocity.z = 0;
                    deltaPosZ = 0; // Don't apply Z movement this frame
                }
                tempPos.z = playerPos.z; // Reset temp position Z

                 // --- 3. Resolve Y-axis Collision ---
                tempPos.y += deltaPosY; // Check intended Y position

                let isOnGround = false; // Reset ground status each frame before check
                canJump = false; // Assume cannot jump unless ground detected

                if (checkCollision(tempPos)) {
                    if (velocity.y < 0) { // Moving down - potential ground collision
                        // Find the exact ground level below the player's current foot position + intended drop
                        const playerFeetY = playerPos.y - playerHeight + deltaPosY;
                        const checkMinX = Math.floor(playerPos.x - playerHalfWidth);
                        const checkMaxX = Math.floor(playerPos.x + playerHalfWidth);
                        const checkMinZ = Math.floor(playerPos.z - playerHalfDepth);
                        const checkMaxZ = Math.floor(playerPos.z + playerHalfDepth);
                        // Check the voxel layer the feet are trying to enter
                        const checkYBelow = Math.floor(playerFeetY);

                        let highestGroundY = -Infinity;
                        for (let cx = checkMinX; cx <= checkMaxX; cx++) {
                            for (let cz = checkMinZ; cz <= checkMaxZ; cz++) {
                                const key = getVoxelKey(cx, checkYBelow, cz);
                                // Check if there's a block below AND if the player's current feet
                                // are above or at the top surface of that block.
                                if (world[key] && (playerPos.y - playerHeight >= checkYBelow + 1 - 0.01)) { // Added tolerance
                                    highestGroundY = Math.max(highestGroundY, checkYBelow + 1); // Top surface is Y+1
                                }
                            }
                        }

                        // If ground was found below where the player is trying to move
                        if (highestGroundY > -Infinity) {
                             deltaPosY = highestGroundY - (playerPos.y - playerHeight); // Adjust delta to land exactly on ground
                             isOnGround = true;
                             canJump = true; // Now we can jump
                             velocity.y = 0; // Stop falling velocity
                        } else {
                            // Collision detected, but couldn't snap perfectly? Stop velocity anyway.
                            velocity.y = 0;
                            deltaPosY = 0;
                        }

                    } else if (velocity.y > 0) { // Moving up - potential ceiling collision
                        // Find the exact ceiling level above the player's head + intended rise
                        const playerHeadY = playerPos.y + deltaPosY;
                        const checkMinX = Math.floor(playerPos.x - playerHalfWidth);
                        const checkMaxX = Math.floor(playerPos.x + playerHalfWidth);
                        const checkMinZ = Math.floor(playerPos.z - playerHalfDepth);
                        const checkMaxZ = Math.floor(playerPos.z + playerHalfDepth);
                        // Check the voxel layer the head is trying to enter
                        const checkYAbove = Math.floor(playerHeadY);

                        let lowestCeilingY = Infinity;
                        for (let cx = checkMinX; cx <= checkMaxX; cx++) {
                             for (let cz = checkMinZ; cz <= checkMaxZ; cz++) {
                                 const key = getVoxelKey(cx, checkYAbove, cz);
                                 // Check if there's a block above AND if the player's current head
                                 // is below or at the bottom surface of that block.
                                 if (world[key] && (playerPos.y <= checkYAbove + 0.01)) { // Added tolerance
                                     lowestCeilingY = Math.min(lowestCeilingY, checkYAbove); // Bottom surface is Y
                                 }
                             }
                         }

                         // If ceiling was found above where the player is trying to move
                         if (lowestCeilingY < Infinity) {
                              deltaPosY = lowestCeilingY - playerPos.y - 0.01; // Adjust delta to stop just below ceiling (small epsilon)
                              velocity.y = 0; // Stop rising velocity
                         } else {
                              // Collision detected, but couldn't snap perfectly? Stop velocity anyway.
                              velocity.y = 0;
                              deltaPosY = 0;
                         }
                    } else {
                        // Moving perfectly horizontally, but still collided? Stop Y velocity just in case.
                        // This might happen if sliding perfectly along a surface.
                         velocity.y = 0;
                         deltaPosY = 0;
                    }
                } // End Y-axis collision check


                // --- Apply Final Movement Deltas ---
                // Apply the potentially adjusted movement deltas for this frame
                playerPos.x += deltaPosX;
                playerPos.y += deltaPosY;
                playerPos.z += deltaPosZ;

                // --- Prevent falling through the void ---
                if (playerPos.y < -20) { // Arbitrary bottom limit
                    console.log("Fell out of world, resetting position.");
                    playerPos.set(0, groundHeight + playerHeight + 5, 0); // Reset higher up
                    velocity.set(0,0,0); // Reset velocity completely
                    canJump = false; // Ensure can't jump immediately after reset
                }

                // Update the voxel FACE outline based on where the player is looking
                updateVoxelOutline();

             } else { // If controls are NOT locked (paused)
                 // Reset velocity if paused to prevent sudden movement on resume
                 velocity.set(0, 0, 0);
                 canJump = false; // Can't jump while paused
                 // Hide outline when paused
                 faceOutlineMesh.visible = false; // <-- Use new mesh name
             }

            // Render the scene regardless of lock state
            renderer.render(scene, camera);
        }

    </script>
</body>
</html>
