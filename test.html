<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Changed Title -->
    <title>Simple 3D Block Game (Three.js) - Chunks!</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #7ec0ee; }
        canvas { display: block; }
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex; /* Use flexbox */
            justify-content: center; /* Center horizontally */
            align-items: center; /* Center vertically */
        }
        #instructions {
            width: 60%;
            background-color: #fff;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
        }
        #crosshair {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 10px; /* Adjusted size */
            height: 1px; /* Line crosshair - horizontal */
            background-color: white;
            transform: translate(-50%, -50%);
            pointer-events: none; /* Don't let it interfere with clicks */
            mix-blend-mode: difference; /* Makes it visible on most backgrounds */
        }
        /* Vertical line for the crosshair */
        #crosshair::after {
            content: '';
            position: absolute;
            left: 50%;
            top: -4.5px; /* Position relative to parent */
            width: 1px;
            height: 10px; /* Match parent width */
            background-color: white;
            transform: translateX(-50%);
            mix-blend-mode: difference;
        }
         #toolbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            background-color: rgba(200, 200, 200, 0.8);
            padding: 5px;
            border-radius: 5px;
            border: 1px solid #555;
            z-index: 10; /* Ensure it's above the canvas */
         }
        .tool-button {
            width: 40px;
            height: 40px;
            border: 2px solid #555;
            cursor: pointer;
            background-size: cover; /* Scale texture nicely */
            image-rendering: pixelated; /* Keep textures blocky */
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            transition: transform 0.1s ease-out, border 0.1s ease-out; /* Smooth transitions */
        }
        .tool-button.selected {
            border: 3px solid #0000ff; /* Blue border for selection */
            transform: scale(1.1); /* Slightly larger when selected */
            box-shadow: 0 0 5px rgba(0, 0, 255, 0.7); /* Optional glow */
        }
        /* Info Display Styles */
        #infoDisplay {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 8px;
            border-radius: 5px;
            font-family: monospace; /* Good for aligning numbers */
            font-size: 12px;
            line-height: 1.4;
            z-index: 5; /* Above canvas, below blocker maybe */
            pointer-events: none; /* Don't capture mouse clicks */
        }
        #infoDisplay span {
            display: inline-block; /* Allows setting width */
            min-width: 35px;      /* Keeps layout stable */
            text-align: right;    /* Align numbers nicely */
            margin-left: 2px;
        }
    </style>
</head>
<body>
    <div id="blocker">
        <div id="instructions">
            <h1>Simple 3D Blocks - Chunks!</h1> <!-- Updated Title -->
            <p>Click to Play</p>
            <p>(W, A, S, D = Move, SPACE = Jump, MOUSE = Look)</p>
            <p>Left Click = Place Block, Right Click = Remove Block</p>
            <p>SCROLL WHEEL = Change Block Type</p>
             <p style="color: darkblue;">World now uses 4x4x4 Chunks!</p>
        </div>
    </div>

    <div id="crosshair"></div>

    <div id="toolbar">
        <!-- Tool buttons will be populated by JS -->
    </div>

    <!-- Info Display -->
    <div id="infoDisplay">
        <div>FPS:<span id="fpsValue">--</span></div>
        <div>Pos:
            X:<span id="posX">--.--</span>|
            Y:<span id="posY">--.--</span>|
            Z:<span id="posZ">--.--</span>
        </div>
        <div>View:
            Yaw:<span id="viewYaw">--.--</span>°|
            Pitch:<span id="viewPitch">--.--</span>°
        </div>
        <div>Chunk: <span id="chunkCoords">--,--,--</span></div> <!-- Added Chunk Coords -->
    </div>

    <!-- Import three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                 "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        let scene, camera, renderer, controls;
        let world = {}; // Will store chunks: { "cx,cy,cz": Chunk }
        const objects = []; // Holds meshes for raycasting (all blocks)

        // --- Chunk Configuration ---
        const chunkSize = 4; // Size of chunks (4x4x4)

        // --- World Dimensions (in blocks, used for generation bounds) ---
        const worldWidth = 20;
        const worldDepth = 20;
        const worldHeight = 10; // Max build height
        const groundHeight = 5; // Initial ground level

        // Movement states
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let moveDown = false;
        let canJump = false;

        // Physics/Movement variables
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const gravity = 30.0;
        const jumpVelocity = 10.0;
        const playerSpeed = 400.0;
        const playerHeight = 1.8;
        const playerWidth = 0.6;
        const playerHalfWidth = playerWidth / 2;
        const playerHalfDepth = playerWidth / 2;

        // DOM Elements
        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');
        const toolbar = document.getElementById('toolbar');
        let fpsValueSpan, posXSpan, posYSpan, posZSpan, viewYawSpan, viewPitchSpan, chunkCoordsSpan; // For info display

        // --- Tool Management ---
        const textureUrls = {
            grass: 'grass.jpg', dirt: 'dirt.jpg', stone: 'cobble.jpg',
            wood: 'wood.jpg', leaves: 'leaves.webp', sand: 'sand.png',
        };
        const toolTypes = Object.keys(textureUrls);
        let currentToolIndex = 0;
        let currentTool = toolTypes[currentToolIndex];

        // --- Texture Loading ---
        const textureLoader = new THREE.TextureLoader();
        const textures = {
            dirt: textureLoader.load(textureUrls.dirt),
            grass: textureLoader.load('grass.jpg'),
            grass_top: textureLoader.load(textureUrls.grass),
            stone: textureLoader.load(textureUrls.stone),
            wood: textureLoader.load('wood.jpg'),
            wood_top: textureLoader.load(textureUrls.wood),
            leaves: textureLoader.load(textureUrls.leaves),
            sand: textureLoader.load(textureUrls.sand),
        };
        for (const key in textures) {
            if (textures[key] instanceof THREE.Texture) {
                textures[key].magFilter = THREE.NearestFilter;
                textures[key].minFilter = THREE.NearestFilter;
            }
        }

        // --- Material Definitions ---
         const materials = {
            grass: [
                new THREE.MeshLambertMaterial({ map: textures.grass }), new THREE.MeshLambertMaterial({ map: textures.grass }),
                new THREE.MeshLambertMaterial({ map: textures.grass_top }), new THREE.MeshLambertMaterial({ map: textures.dirt }),
                new THREE.MeshLambertMaterial({ map: textures.grass }), new THREE.MeshLambertMaterial({ map: textures.grass }),
            ],
            dirt: new THREE.MeshLambertMaterial({ map: textures.dirt }),
            stone: new THREE.MeshLambertMaterial({ map: textures.stone }),
            wood: [
                 new THREE.MeshLambertMaterial({ map: textures.wood }), new THREE.MeshLambertMaterial({ map: textures.wood }),
                 new THREE.MeshLambertMaterial({ map: textures.wood_top }), new THREE.MeshLambertMaterial({ map: textures.wood_top }),
                 new THREE.MeshLambertMaterial({ map: textures.wood }), new THREE.MeshLambertMaterial({ map: textures.wood }),
            ],
            leaves: new THREE.MeshLambertMaterial({ map: textures.leaves, alphaTest: 0.5, side: THREE.DoubleSide }),
            sand: new THREE.MeshLambertMaterial({ map: textures.sand }),
        };

        // --- Raycasting ---
        const raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, 0, -1), 0, 5);
        const pointer = new THREE.Vector2(0, 0);

        // --- Face Outline ---
        const faceOutlineGeometry = new THREE.PlaneGeometry(1, 1);
        const faceOutlineMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide, transparent: true, opacity: 0.4, depthTest: false });
        const faceOutlineMesh = new THREE.Mesh(faceOutlineGeometry, faceOutlineMaterial);
        faceOutlineMesh.visible = false;

        // Timing
        let prevTime = performance.now();
        let lastInfoUpdateTime = 0;


        // ===============================================================
        // ===== CHUNK CLASS DEFINITION ==================================
        // ===============================================================
        class Chunk {
            constructor(chunkX, chunkY, chunkZ) {
                this.chunkX = chunkX;
                this.chunkY = chunkY;
                this.chunkZ = chunkZ;
                this.worldOrigin = new THREE.Vector3( // Calculate world position of chunk corner (0,0,0)
                    chunkX * chunkSize,
                    chunkY * chunkSize,
                    chunkZ * chunkSize
                );
                // 3D array to store voxel data { type: string, mesh: THREE.Mesh }
                this.voxels = this.initVoxels();
            }

            // Initialize the 3D array with null values
            initVoxels() {
                const arr = new Array(chunkSize);
                for (let x = 0; x < chunkSize; x++) {
                    arr[x] = new Array(chunkSize);
                    for (let y = 0; y < chunkSize; y++) {
                        arr[x][y] = new Array(chunkSize).fill(null);
                    }
                }
                return arr;
            }

            // Get voxel data at LOCAL coordinates (0 to chunkSize-1)
            getVoxel(localX, localY, localZ) {
                 if (this.isValidLocalCoord(localX, localY, localZ)) {
                     return this.voxels[localX][localY][localZ];
                 }
                 return null; // Out of bounds
            }

            // Set voxel data at LOCAL coordinates
            // Voxel data should be an object like { type: 'grass', mesh: THREE.Mesh } or null
            setVoxel(localX, localY, localZ, voxelData) {
                 if (this.isValidLocalCoord(localX, localY, localZ)) {
                    this.voxels[localX][localY][localZ] = voxelData;
                    return true;
                 }
                 return false; // Out of bounds
            }

             // Check if local coordinates are within the chunk bounds
            isValidLocalCoord(lx, ly, lz) {
                return lx >= 0 && lx < chunkSize &&
                       ly >= 0 && ly < chunkSize &&
                       lz >= 0 && lz < chunkSize;
            }

            // Convert WORLD coordinates to LOCAL chunk coordinates
            worldToLocal(worldX, worldY, worldZ) {
                // Use modulo and floor to handle negative coords correctly
                const localX = THREE.MathUtils.euclideanModulo(Math.floor(worldX), chunkSize);
                const localY = THREE.MathUtils.euclideanModulo(Math.floor(worldY), chunkSize);
                const localZ = THREE.MathUtils.euclideanModulo(Math.floor(worldZ), chunkSize);
                return { x: localX, y: localY, z: localZ };
            }

            // Convert LOCAL chunk coordinates to WORLD coordinates
            localToWorld(localX, localY, localZ) {
                return {
                    x: this.worldOrigin.x + localX,
                    y: this.worldOrigin.y + localY,
                    z: this.worldOrigin.z + localZ
                };
            }
        }
        // ===============================================================
        // ===== END CHUNK CLASS =========================================
        // ===============================================================


        // --- Chunk Utility Functions ---

        // Calculate chunk coordinates from world coordinates
        function getChunkCoords(worldX, worldY, worldZ) {
            const cx = Math.floor(worldX / chunkSize);
            const cy = Math.floor(worldY / chunkSize);
            const cz = Math.floor(worldZ / chunkSize);
            return { x: cx, y: cy, z: cz };
        }

        // Generate a unique key string for chunk coordinates
        function getChunkKey(chunkX, chunkY, chunkZ) {
            return `${chunkX},${chunkY},${chunkZ}`;
        }

        // Get the Chunk object for given world coordinates. Creates chunk if it doesn't exist.
        function getChunk(worldX, worldY, worldZ) {
            const { x: cx, y: cy, z: cz } = getChunkCoords(worldX, worldY, worldZ);
            const key = getChunkKey(cx, cy, cz);
            if (!world[key]) {
                // console.log(`Creating chunk at ${key}`); // Debug: Log chunk creation
                world[key] = new Chunk(cx, cy, cz);
            }
            return world[key];
        }

        // Get voxel data (type and mesh) from world coordinates
        function getVoxelDataFromWorld(worldX, worldY, worldZ) {
            const chunk = getChunk(worldX, worldY, worldZ); // Gets or creates chunk
            // Chunk might be newly created and empty, so check if it exists first (getChunk ensures this)
             if (chunk) {
                 const localCoords = chunk.worldToLocal(worldX, worldY, worldZ);
                 return chunk.getVoxel(localCoords.x, localCoords.y, localCoords.z);
             }
            return null; // No chunk found (shouldn't happen with getChunk)
        }


        // --- Utility Functions ---
        // (getVoxelKey removed)

        // Gets the correct material (single or array) for a block type
        function getMaterial(type) {
             if (type === 'grass') return materials.grass;
             if (type === 'wood') return materials.wood;
             return materials[type] || materials.stone; // Default to stone
        }


        // --- Voxel Management (CHUNK-AWARE) ---
        function addVoxel(worldX, worldY, worldZ, type) {
            worldX = Math.floor(worldX); // Ensure integer world coordinates
            worldY = Math.floor(worldY);
            worldZ = Math.floor(worldZ);

            // Prevent building outside defined height limits or replacing existing
            const existingVoxel = getVoxelDataFromWorld(worldX, worldY, worldZ);
            if (existingVoxel || worldY < 0 || worldY >= worldHeight) {
                 // console.log(`Cannot add voxel at ${worldX},${worldY},${worldZ}. Existing: ${!!existingVoxel}, Height: ${worldY}`);
                return;
            }

            const chunk = getChunk(worldX, worldY, worldZ); // Get or create the chunk
            const localCoords = chunk.worldToLocal(worldX, worldY, worldZ);

             // Ensure material exists
             let material = getMaterial(type);
             if (!material) {
                 console.warn(`No material found for type: ${type}. Using stone.`);
                 type = 'stone';
                 material = materials.stone;
             }

            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const mesh = new THREE.Mesh(geometry, material);

            // Position mesh at the center of the WORLD voxel space
            mesh.position.set(worldX + 0.5, worldY + 0.5, worldZ + 0.5);
            // Store WORLD voxel coordinates and type in userData for raycasting/interaction
            mesh.userData = { x: worldX, y: worldY, z: worldZ, type: type };

            // Add mesh to the scene and raycasting list
            scene.add(mesh);
            objects.push(mesh);

            // Store voxel data (type and mesh reference) in the chunk
            chunk.setVoxel(localCoords.x, localCoords.y, localCoords.z, {
                type: type,
                mesh: mesh
            });
            // console.log(`Added ${type} at ${worldX},${worldY},${worldZ} (Chunk ${chunk.chunkX},${chunk.chunkY},${chunk.chunkZ}, Local ${localCoords.x},${localCoords.y},${localCoords.z})`);
        }

         function removeVoxel(worldX, worldY, worldZ) {
            worldX = Math.floor(worldX);
            worldY = Math.floor(worldY);
            worldZ = Math.floor(worldZ);

            const chunk = getChunk(worldX, worldY, worldZ); // Get chunk (might be empty)
            const localCoords = chunk.worldToLocal(worldX, worldY, worldZ);
            const voxelData = chunk.getVoxel(localCoords.x, localCoords.y, localCoords.z);

            if (voxelData && voxelData.mesh) {
                // Remove from scene
                scene.remove(voxelData.mesh);

                // Remove from raycasting list
                const index = objects.indexOf(voxelData.mesh);
                if (index > -1) {
                    objects.splice(index, 1);
                }

                 // Dispose geometry/material (optional but good practice)
                 voxelData.mesh.geometry.dispose();
                 // Material disposal is trickier with shared/array materials - skip for now

                // Remove voxel data from the chunk
                chunk.setVoxel(localCoords.x, localCoords.y, localCoords.z, null);
                // console.log(`Removed voxel at ${worldX},${worldY},${worldZ}`);
                return true; // Indicate success
            }
            // console.log(`No voxel found to remove at ${worldX},${worldY},${worldZ}`);
            return false; // Indicate nothing was removed
        }

        // --- World Generation (uses new addVoxel) ---
        function generateWorld() {
            console.log("Generating world...")
            // Simple flat world base
            for (let x = -worldWidth / 2; x < worldWidth / 2; x++) {
                for (let z = -worldDepth / 2; z < worldDepth / 2; z++) {
                    for (let y = 0; y < groundHeight; y++) {
                        let type = 'stone';
                         if (y === groundHeight - 1) type = 'grass';
                         else if (y >= groundHeight - 3) type = 'dirt';
                         addVoxel(x, y, z, type); // addVoxel handles chunk creation now
                    }
                }
            }
             // Add simple "trees"
            for (let i = 0; i < 5; i++) {
                const treeX = Math.floor(Math.random() * worldWidth - worldWidth / 2);
                const treeZ = Math.floor(Math.random() * worldDepth - worldDepth / 2);
                const treeHeight = 4 + Math.floor(Math.random() * 3);

                 // Check if the base block is suitable (use getVoxelDataFromWorld)
                 const baseVoxelData = getVoxelDataFromWorld(treeX, groundHeight - 1, treeZ);
                 if (baseVoxelData && baseVoxelData.type === 'grass') {
                     // Trunk
                     for(let y = groundHeight; y < groundHeight + treeHeight; y++) {
                         addVoxel(treeX, y, treeZ, 'wood');
                     }
                     // Leaves
                    const leavesY = groundHeight + treeHeight;
                    for(let lx = -2; lx <= 2; lx++) {
                        for(let lz = -2; lz <= 2; lz++) {
                            for(let ly = 0; ly <= 2; ly++) {
                                if (Math.abs(lx) === 2 && Math.abs(lz) === 2) continue;
                                if (ly === 2 && (Math.abs(lx) > 1 || Math.abs(lz) > 1)) continue;
                                const currentY = leavesY + ly;
                                const currentX = treeX + lx;
                                const currentZ = treeZ + lz;
                                if (lx === 0 && lz === 0 && ly < 1) continue;

                                // Check if space is empty before adding leaves
                                if (!getVoxelDataFromWorld(currentX, currentY, currentZ)) {
                                     addVoxel(currentX, currentY, currentZ, 'leaves');
                                }
                            }
                        }
                    }
                 }
            }
            console.log("World generation complete.");
        }

        // --- Toolbar UI Management (Unchanged) ---
        function updateToolbarSelection() { /* ... no changes ... */
            document.querySelectorAll('#toolbar .tool-button').forEach(btn => {
                btn.classList.remove('selected');
            });
            const selectedButton = document.getElementById(`tool-${currentTool}`);
            if (selectedButton) {
                selectedButton.classList.add('selected');
            } else {
                 console.error(`Toolbar button not found for type: ${currentTool}`);
            }
        }
        function setupToolbar() { /* ... no changes ... */
             toolTypes.forEach(type => {
                const url = textureUrls[type];
                const button = document.createElement('div');
                button.id = `tool-${type}`;
                button.classList.add('tool-button');
                button.dataset.type = type;

                if (url) {
                     // For local files:
                    button.style.backgroundImage = `url(${url})`;
                 } else {
                    button.style.backgroundColor = '#ff00ff';
                    console.warn(`Missing texture URL for toolbar type: ${type}`);
                }

                button.addEventListener('click', () => {
                    currentTool = type;
                    currentToolIndex = toolTypes.indexOf(type);
                    updateToolbarSelection();
                });

                toolbar.appendChild(button);
            });
            updateToolbarSelection();
        }


        // --- Player AABB Helper (Unchanged) ---
        function getPlayerAABB(position) { /* ... no changes ... */
            return new THREE.Box3(
                new THREE.Vector3(position.x - playerHalfWidth, position.y - playerHeight, position.z - playerHalfDepth),
                new THREE.Vector3(position.x + playerHalfWidth, position.y,                position.z + playerHalfDepth)
            );
        }

        // --- Collision Check Function (CHUNK-AWARE) ---
        function checkCollision(playerPos) {
            const playerAABB = getPlayerAABB(playerPos);
            // Determine the range of world voxels the player AABB *might* overlap with
            const minX = Math.floor(playerAABB.min.x);
            const maxX = Math.floor(playerAABB.max.x);
            const minY = Math.floor(playerAABB.min.y);
            const maxY = Math.floor(playerAABB.max.y);
            const minZ = Math.floor(playerAABB.min.z);
            const maxZ = Math.floor(playerAABB.max.z);

            // Iterate through the potentially overlapping WORLD voxels
            for (let x = minX; x <= maxX; x++) {
                for (let y = minY; y <= maxY; y++) {
                    for (let z = minZ; z <= maxZ; z++) {
                        // Use the new function to check for voxel existence via chunks
                        const voxelData = getVoxelDataFromWorld(x, y, z);
                        if (voxelData) { // If voxelData exists (meaning block is present)
                            // Create a bounding box for the world block
                            const blockAABB = new THREE.Box3(
                                new THREE.Vector3(x, y, z),
                                new THREE.Vector3(x + 1, y + 1, z + 1)
                            );
                            // Check if the player's AABB intersects this block's AABB
                            if (playerAABB.intersectsBox(blockAABB)) {
                                return true; // Collision detected
                            }
                        }
                    }
                }
            }
            return false; // No collision found
        }


        // --- Initialization Function ---
        function init() {
            // --- Scene ---
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 10, 90);

            // --- Camera ---
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, groundHeight + playerHeight + 0.5, 5);

            // --- Renderer ---
            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // --- Lighting ---
            const ambientLight = new THREE.AmbientLight(0xcccccc, 0.9);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(50, 80, 40);
            scene.add(directionalLight);

             // --- Controls (Pointer Lock) ---
            controls = new PointerLockControls(camera, document.body);
            scene.add(controls.getObject());
            instructions.addEventListener('click', () => controls.lock());
            controls.addEventListener('lock', () => {
                instructions.style.display = 'none';
                blocker.style.display = 'none';
            });
            controls.addEventListener('unlock', () => {
                blocker.style.display = 'flex';
                instructions.style.display = '';
            });

             // --- Keyboard Input (Unchanged) ---
            const onKeyDown = (event) => { /* ... no changes ... */
                 if (event.repeat) return;
                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = true; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                    case 'ArrowRight': case 'KeyD': moveRight = true; break;
                    case 'Space': if (canJump) { velocity.y = jumpVelocity; canJump = false; } break;
                }
            };
             const onKeyUp = (event) => { /* ... no changes ... */
                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = false; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                    case 'ArrowRight': case 'KeyD': moveRight = false; break;
                }
            };
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);


            // --- Mouse Input (Block Placement/Removal - Uses new add/remove) ---
             window.addEventListener('mousedown', (event) => {
                 if (!controls.isLocked) return;
                 const intersection = getIntersection(); // Raycasting remains the same
                 if (!intersection) return;

                 const obj = intersection.object;
                 const hitCoords = obj.userData; // Still uses WORLD coords stored in mesh

                 if (!hitCoords || typeof hitCoords.x === 'undefined') {
                     console.log("Clicked on non-world object or object missing coords.");
                     return;
                 }

                 const normal = intersection.face.normal.clone();

                 if (event.button === 0) { // Left click - Place block
                     const placeCoords = {
                         x: hitCoords.x + normal.x,
                         y: hitCoords.y + normal.y,
                         z: hitCoords.z + normal.z
                     };

                     // Player collision check for placement (Unchanged logic, uses world coords)
                     const blockAABB = new THREE.Box3(
                         new THREE.Vector3(placeCoords.x, placeCoords.y, placeCoords.z),
                         new THREE.Vector3(placeCoords.x + 1, placeCoords.y + 1, placeCoords.z + 1)
                     );
                     const playerAABB = getPlayerAABB(controls.getObject().position);

                     if (!playerAABB.intersectsBox(blockAABB)) {
                         // Use the new chunk-aware addVoxel
                         addVoxel(placeCoords.x, placeCoords.y, placeCoords.z, currentTool);
                     } else {
                         console.log("Cannot place block inside player");
                     }

                 } else if (event.button === 2) { // Right click - Remove block
                    // Use the new chunk-aware removeVoxel, using the WORLD coordinates from the hit mesh
                    removeVoxel(hitCoords.x, hitCoords.y, hitCoords.z);
                 }
             });

            // --- Scroll Wheel Input (Tool Switching - Unchanged) ---
            window.addEventListener('wheel', (event) => { /* ... no changes ... */
                if (!controls.isLocked) return;
                event.preventDefault();
                const scrollDirection = Math.sign(event.deltaY);
                if (scrollDirection > 0) {
                    currentToolIndex = (currentToolIndex + 1) % toolTypes.length;
                } else if (scrollDirection < 0) {
                    currentToolIndex = (currentToolIndex - 1 + toolTypes.length) % toolTypes.length;
                }
                currentTool = toolTypes[currentToolIndex];
                updateToolbarSelection();
            }, { passive: false });


            // --- Get References to Info Display Elements ---
            fpsValueSpan = document.getElementById('fpsValue');
            posXSpan = document.getElementById('posX');
            posYSpan = document.getElementById('posY');
            posZSpan = document.getElementById('posZ');
            viewYawSpan = document.getElementById('viewYaw');
            viewPitchSpan = document.getElementById('viewPitch');
            chunkCoordsSpan = document.getElementById('chunkCoords'); // Get chunk span

            // --- World Generation & UI Setup ---
            generateWorld(); // Calls the new generation function
            setupToolbar();

            // --- Add Face Outline to Scene ---
            scene.add(faceOutlineMesh);

            // --- Window Resize Listener ---
            window.addEventListener('resize', onWindowResize);
        }

        // --- Resize Handler (Unchanged) ---
        function onWindowResize() { /* ... no changes ... */
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Raycasting Function (Unchanged) ---
        // Raycasting still works on the global `objects` array, which contains all individual block meshes
         function getIntersection() { /* ... no changes ... */
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(objects, false);
             const validIntersects = intersects.filter(intersect => intersect.object !== faceOutlineMesh);
             return validIntersects.length > 0 ? validIntersects[0] : null;
         }

        // --- Update Voxel Face Outline Position/Visibility/Orientation (Unchanged) ---
        // This uses the intersection data which still provides world coordinates from mesh.userData
        function updateVoxelOutline() { /* ... no changes ... */
             const intersection = getIntersection();
             if (intersection && intersection.object.userData && typeof intersection.object.userData.x !== 'undefined' && intersection.face) {
                const blockCenter = intersection.object.position;
                const faceNormal = intersection.face.normal.clone();
                const outlinePosition = blockCenter.clone().addScaledVector(faceNormal, 0.501);
                faceOutlineMesh.position.copy(outlinePosition);
                const lookAtTarget = outlinePosition.clone().add(faceNormal);
                faceOutlineMesh.lookAt(lookAtTarget);
                faceOutlineMesh.visible = true;
             } else {
                 faceOutlineMesh.visible = false;
             }
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = Math.max(0.0001, Math.min(0.05, (time - prevTime) / 1000));
            prevTime = time;

            // --- Calculate and Display Info ---
            const fps = 1 / delta;
            const playerPos = controls.getObject().position;
            const playerRot = controls.getObject().rotation;
            const yawDeg = THREE.MathUtils.radToDeg(playerRot.y);
            const pitchDeg = THREE.MathUtils.radToDeg(playerRot.x);

            // Calculate player's current chunk coordinates
            const playerChunkCoords = getChunkCoords(playerPos.x, playerPos.y, playerPos.z);

            if (fpsValueSpan) fpsValueSpan.textContent = Math.round(fps);
            if (posXSpan) posXSpan.textContent = playerPos.x.toFixed(2);
            if (posYSpan) posYSpan.textContent = playerPos.y.toFixed(2);
            if (posZSpan) posZSpan.textContent = playerPos.z.toFixed(2);
            if (viewYawSpan) viewYawSpan.textContent = ((yawDeg % 360 + 360) % 360).toFixed(1);
            if (viewPitchSpan) viewPitchSpan.textContent = pitchDeg.toFixed(1);
            // Display player chunk coordinates
            if (chunkCoordsSpan) chunkCoordsSpan.textContent = `${playerChunkCoords.x},${playerChunkCoords.y},${playerChunkCoords.z}`;


             if (controls.isLocked) {
                // --- Physics & Movement (Largely Unchanged) ---
                // It uses the chunk-aware checkCollision function now

                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= gravity * delta;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                // direction.normalize(); // Optional for consistent speed

                const cameraDirection = new THREE.Vector3();
                controls.getObject().getWorldDirection(cameraDirection);
                const forward = new THREE.Vector3(cameraDirection.x, 0, cameraDirection.z).normalize();
                const right = new THREE.Vector3();
                right.crossVectors(forward, camera.up).normalize(); // Corrected strafe

                const currentSpeed = playerSpeed * delta;
                let velocityChangeX = 0;
                let velocityChangeZ = 0;
                if (direction.z !== 0) {
                    velocityChangeX += forward.x * direction.z * currentSpeed;
                    velocityChangeZ += forward.z * direction.z * currentSpeed;
                }
                if (direction.x !== 0) {
                    velocityChangeX += right.x * direction.x * currentSpeed;
                    velocityChangeZ += right.z * direction.x * currentSpeed;
                }
                velocity.x += velocityChangeX;
                velocity.z += velocityChangeZ;


                // --- Collision Detection & Resolution (Axis-by-Axis AABB - uses new checkCollision) ---
                let deltaPosX = velocity.x * delta;
                let deltaPosY = velocity.y * delta;
                let deltaPosZ = velocity.z * delta;
                let tempPos = playerPos.clone();

                // Resolve X
                tempPos.x += deltaPosX;
                if (checkCollision(tempPos)) { velocity.x = 0; deltaPosX = 0; }
                tempPos.x = playerPos.x;

                // Resolve Z
                tempPos.z += deltaPosZ;
                if (checkCollision(tempPos)) { velocity.z = 0; deltaPosZ = 0; }
                tempPos.z = playerPos.z;

                // Resolve Y
                tempPos.y += deltaPosY;
                let isOnGround = false;
                canJump = false;
                if (checkCollision(tempPos)) {
                    if (velocity.y < 0) { // Falling
                         // Simplified ground check using the chunk-aware checkCollision
                         // Try to place feet just above the collision point
                         const checkMinX = Math.floor(playerPos.x - playerHalfWidth);
                         const checkMaxX = Math.floor(playerPos.x + playerHalfWidth);
                         const checkMinZ = Math.floor(playerPos.z - playerHalfDepth);
                         const checkMaxZ = Math.floor(playerPos.z + playerHalfDepth);
                         const checkYBelow = Math.floor(playerPos.y - playerHeight + deltaPosY); // Y coord feet are trying to enter

                         let highestGroundY = -Infinity;
                         for (let cx = checkMinX; cx <= checkMaxX; cx++) {
                             for (let cz = checkMinZ; cz <= checkMaxZ; cz++) {
                                 const voxelData = getVoxelDataFromWorld(cx, checkYBelow, cz); // Use chunk check
                                 if (voxelData && (playerPos.y - playerHeight >= checkYBelow + 1 - 0.01)) {
                                     highestGroundY = Math.max(highestGroundY, checkYBelow + 1);
                                 }
                             }
                         }

                         if (highestGroundY > -Infinity) {
                              deltaPosY = highestGroundY - (playerPos.y - playerHeight);
                              isOnGround = true;
                              canJump = true;
                              velocity.y = 0;
                         } else {
                              velocity.y = 0; deltaPosY = 0; // Generic stop if snap fails
                         }

                    } else if (velocity.y > 0) { // Jumping/Rising
                         // Simplified ceiling check using chunk-aware checkCollision
                         const checkMinX = Math.floor(playerPos.x - playerHalfWidth);
                         const checkMaxX = Math.floor(playerPos.x + playerHalfWidth);
                         const checkMinZ = Math.floor(playerPos.z - playerHalfDepth);
                         const checkMaxZ = Math.floor(playerPos.z + playerHalfDepth);
                         const checkYAbove = Math.floor(playerPos.y + deltaPosY); // Y coord head is trying to enter

                         let lowestCeilingY = Infinity;
                          for (let cx = checkMinX; cx <= checkMaxX; cx++) {
                             for (let cz = checkMinZ; cz <= checkMaxZ; cz++) {
                                  const voxelData = getVoxelDataFromWorld(cx, checkYAbove, cz); // Use chunk check
                                  if (voxelData && (playerPos.y <= checkYAbove + 0.01)) {
                                     lowestCeilingY = Math.min(lowestCeilingY, checkYAbove);
                                 }
                             }
                         }
                          if (lowestCeilingY < Infinity) {
                              deltaPosY = lowestCeilingY - playerPos.y - 0.01;
                              velocity.y = 0;
                         } else {
                             velocity.y = 0; deltaPosY = 0; // Generic stop if snap fails
                         }
                    } else { // Moving horizontally, but collided?
                         velocity.y = 0; deltaPosY = 0;
                    }
                }


                // --- Apply Final Movement Deltas ---
                playerPos.x += deltaPosX;
                playerPos.y += deltaPosY;
                playerPos.z += deltaPosZ;

                // --- Prevent falling through the void ---
                if (playerPos.y < -20) {
                    console.log("Fell out of world, resetting position.");
                    playerPos.set(0, groundHeight + playerHeight + 5, 0);
                    velocity.set(0,0,0);
                    canJump = false;
                }

                // Update voxel outline
                updateVoxelOutline();

             } else { // Paused
                 velocity.set(0, 0, 0);
                 canJump = false;
                 faceOutlineMesh.visible = false;
             }

            // Render
            renderer.render(scene, camera);
        }

        // --- Start ---
        init();
        animate();

    </script>
</body>
</html>
