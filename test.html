<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple 3D Block Game (Three.js)</title>
    <style>
        /* ... (Keep all existing CSS) ... */
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #7ec0ee; }
        canvas { display: block; }
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex; /* Use flexbox */
            justify-content: center; /* Center horizontally */
            align-items: center; /* Center vertically */
        }
        #instructions {
            width: 60%;
            background-color: #fff;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
        }
        #crosshair {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 10px; /* Adjusted size */
            height: 1px; /* Line crosshair - horizontal */
            background-color: white;
            transform: translate(-50%, -50%);
            pointer-events: none; /* Don't let it interfere with clicks */
            mix-blend-mode: difference; /* Makes it visible on most backgrounds */
        }
        /* Vertical line for the crosshair */
        #crosshair::after {
            content: '';
            position: absolute;
            left: 50%;
            top: -4.5px; /* Position relative to parent */
            width: 1px;
            height: 10px; /* Match parent width */
            background-color: white;
            transform: translateX(-50%);
            mix-blend-mode: difference;
        }
         #toolbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            background-color: rgba(200, 200, 200, 0.8);
            padding: 5px;
            border-radius: 5px;
            border: 1px solid #555;
            z-index: 10; /* Ensure it's above the canvas */
         }
        .tool-button {
            width: 40px;
            height: 40px;
            border: 2px solid #555;
            cursor: pointer;
            background-size: cover; /* Scale texture nicely */
            image-rendering: pixelated; /* Keep textures blocky */
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            transition: transform 0.1s ease-out, border 0.1s ease-out; /* Smooth transitions */
        }
        .tool-button.selected {
            border: 3px solid #0000ff; /* Blue border for selection */
            transform: scale(1.1); /* Slightly larger when selected */
            box-shadow: 0 0 5px rgba(0, 0, 255, 0.7); /* Optional glow */
        }
        /* CSS Rules for background images are now handled by JS */
    </style>
</head>
<body>
    <div id="blocker">
        <div id="instructions">
            <h1>Simple 3D Blocks</h1>
            <p>Click to Play</p>
            <p>(W, A, S, D = Move, SPACE = Jump, SHIFT/CTRL = Down,  = Look)</p>
            <p>Left Click = Place Block, Right Click = Remove Block</p>
            <p>SCROLL WHEEL = Change Block Type</p> <!-- Added instruction -->
        </div>
    </div>

    <div id="crosshair"></div> <!-- Adjusted crosshair element -->

    <div id="toolbar">
        <!-- Tool buttons will be populated by JS -->
    </div>

    <!-- Import three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                 "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // ... (scene, camera, renderer, controls, world, objects, world settings, etc. remain the same) ...
        let scene, camera, renderer, controls;
        let world = {};
        const objects = [];

        const worldWidth = 20;
        const worldDepth = 20;
        const worldHeight = 10;
        const groundHeight = 5;

        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let moveUp = false; // Keep if you intend to use it later
        let moveDown = false;

        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const gravity = 30.0;
        const jumpVelocity = 10.0;
        const playerSpeed = 400.0;
        const playerHeight = 1.8;

        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');
        const toolbar = document.getElementById('toolbar');

        // --- Define URLs for Toolbar Icons ---
        const textureUrls = {
            grass: 'grass.jpg', // Top view
            dirt: 'dirt.jpg',
            stone: 'cobble.jpg',
            wood: 'wood.jpg',   // Top view
            leaves: 'leaves.webp',
            sand: 'sand.jpg',
        };

        // --- Define Tool Order (NEW) ---
        const toolTypes = Object.keys(textureUrls); // Get types in object definition order
        let currentToolIndex = 0; // Start with the first tool
        let currentTool = toolTypes[currentToolIndex]; // Initialize currentTool based on index

        // --- Texture Loading ---
        const textureLoader = new THREE.TextureLoader();
        const textures = {
            dirt: textureLoader.load(textureUrls.dirt),
            grass: textureLoader.load('grass.jpg'), // Side texture
            grass_top: textureLoader.load(textureUrls.grass), // Top texture & icon
            stone: textureLoader.load(textureUrls.stone),
            wood: textureLoader.load('wood.jpg'), // Side texture
            wood_top: textureLoader.load(textureUrls.wood), // Top texture & icon
            leaves: textureLoader.load(textureUrls.leaves),
            sand: textureLoader.load(textureUrls.sand),
        };

        // Improve texture appearance
        for (const key in textures) {
            if (textures[key] && textures[key] instanceof THREE.Texture) {
                textures[key].magFilter = THREE.NearestFilter;
                textures[key].minFilter = THREE.NearestFilter;
            }
        }

        // --- Material Definitions ---
        const materials = {
            grass: [
                new THREE.MeshLambertMaterial({ map: textures.grass }), // right (+x)
                new THREE.MeshLambertMaterial({ map: textures.grass }), // left (-x)
                new THREE.MeshLambertMaterial({ map: textures.grass_top }), // top (+y)
                new THREE.MeshLambertMaterial({ map: textures.dirt }),    // bottom (-y)
                new THREE.MeshLambertMaterial({ map: textures.grass }), // front (+z)
                new THREE.MeshLambertMaterial({ map: textures.grass }), // back (-z)
            ],
            dirt: new THREE.MeshLambertMaterial({ map: textures.dirt }),
            stone: new THREE.MeshLambertMaterial({ map: textures.stone }),
            wood: [
                 new THREE.MeshLambertMaterial({ map: textures.wood }), // right
                 new THREE.MeshLambertMaterial({ map: textures.wood }), // left
                 new THREE.MeshLambertMaterial({ map: textures.wood_top }), // top
                 new THREE.MeshLambertMaterial({ map: textures.wood_top }), // bottom
                 new THREE.MeshLambertMaterial({ map: textures.wood }), // front
                 new THREE.MeshLambertMaterial({ map: textures.wood }), // back
            ],
            leaves: new THREE.MeshLambertMaterial({
                 map: textures.leaves,
                 alphaTest: 0.5,
                 side: THREE.DoubleSide
                }),
            sand: new THREE.MeshLambertMaterial({ map: textures.sand }),
        };


        // --- Raycasting ---
        const raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, 0, -1), 0, 5); // Limit raycast distance slightly
        const pointer = new THREE.Vector2(0, 0); // Center of screen

        const voxelOutlineGeometry = new THREE.BoxGeometry(1.01, 1.01, 1.01);
        const voxelOutlineMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true, depthTest: false, transparent: true, opacity: 0.7 });
        const voxelOutlineMesh = new THREE.Mesh(voxelOutlineGeometry, voxelOutlineMaterial);
        voxelOutlineMesh.visible = false;

        let prevTime = performance.now();

        init();
        animate();

        // --- Utility Functions ---
        function getVoxelKey(x, y, z) { return `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`; }

        function getMaterial(type) {
             if (type === 'grass') return materials.grass;
             if (type === 'wood') return materials.wood;
             return materials[type] || materials.stone;
        }

        // --- Voxel Management ---
        function addVoxel(x, y, z, type) {
            const key = getVoxelKey(x, y, z);
            if (world[key] || y < 0 || y >= worldHeight) return;

             const material = getMaterial(type);
             if (!material) {
                 console.warn(`No material for type: ${type}. Using stone.`);
                 type = 'stone';
                 material = materials.stone;
             }

            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const mesh = new THREE.Mesh(geometry, material);

            mesh.position.set(x + 0.5, y + 0.5, z + 0.5);
            mesh.userData = { x, y, z, type };

            scene.add(mesh);
            objects.push(mesh);
            world[key] = { type: type, mesh: mesh };
        }

        function removeVoxel(x, y, z) {
            const key = getVoxelKey(x, y, z);
            const voxelData = world[key];
            if (voxelData) {
                scene.remove(voxelData.mesh);
                const index = objects.indexOf(voxelData.mesh);
                if (index > -1) objects.splice(index, 1);
                // Optional: Dispose geometry/material for large worlds
                // voxelData.mesh.geometry.dispose();
                // (Handle material array disposal if needed)
                delete world[key];
                return true;
            }
            return false;
        }

        // --- World Generation ---
        function generateWorld() {
            // Flat world
            for (let x = -worldWidth / 2; x < worldWidth / 2; x++) {
                for (let z = -worldDepth / 2; z < worldDepth / 2; z++) {
                    for (let y = 0; y < groundHeight; y++) {
                        let type = 'stone';
                         if (y === groundHeight - 1) type = 'grass';
                         else if (y >= groundHeight - 3) type = 'dirt';
                         addVoxel(x, y, z, type);
                    }
                }
            }
             // Simple "trees"
            for (let i = 0; i < 5; i++) {
                const treeX = Math.floor(Math.random() * worldWidth - worldWidth / 2);
                const treeZ = Math.floor(Math.random() * worldDepth - worldDepth / 2);
                const treeHeight = 4 + Math.floor(Math.random() * 3);
                const groundKey = getVoxelKey(treeX, groundHeight - 1, treeZ);

                 if (world[groundKey] && world[groundKey].type === 'grass') {
                     for(let y = groundHeight; y < groundHeight + treeHeight; y++) {
                         addVoxel(treeX, y, treeZ, 'wood');
                     }
                    const leavesY = groundHeight + treeHeight;
                    for(let lx = -2; lx <= 2; lx++) {
                        for(let lz = -2; lz <= 2; lz++) {
                            for(let ly = 0; ly <= 2; ly++) {
                                if (Math.abs(lx) === 2 && Math.abs(lz) === 2) continue;
                                if (ly === 2 && (Math.abs(lx) > 1 || Math.abs(lz) > 1)) continue;
                                const currentY = leavesY + ly;
                                const currentX = treeX + lx;
                                const currentZ = treeZ + lz;
                                if (lx === 0 && lz === 0 && ly < 1) continue;
                                const key = getVoxelKey(currentX, currentY, currentZ);
                                if (!world[key]) {
                                     addVoxel(currentX, currentY, currentZ, 'leaves');
                                }
                            }
                        }
                    }
                 }
            }
        }

        // --- Toolbar Selection Update Function (NEW) ---
        function updateToolbarSelection() {
            document.querySelectorAll('#toolbar .tool-button').forEach(btn => {
                btn.classList.remove('selected');
            });
            const selectedButton = document.getElementById(`tool-${currentTool}`);
            if (selectedButton) {
                selectedButton.classList.add('selected');
            } else {
                 console.error(`Toolbar button not found for type: ${currentTool}`);
            }
        }

        // --- Toolbar Setup Function (Modified) ---
        function setupToolbar() {
            // Use the ordered toolTypes array
            toolTypes.forEach(type => {
                const url = textureUrls[type];
                const button = document.createElement('div');
                button.id = `tool-${type}`;
                button.classList.add('tool-button');
                button.dataset.type = type;

                if (url) {
                    button.style.backgroundImage = `url(${url})`;
                } else {
                    button.style.backgroundColor = '#ff00ff';
                    console.warn(`Missing texture URL for toolbar type: ${type}`);
                }

                button.addEventListener('click', () => {
                    // Update both name and index when clicking
                    currentTool = type;
                    currentToolIndex = toolTypes.indexOf(type);
                    updateToolbarSelection(); // Use the update function
                });

                toolbar.appendChild(button);
            });

            // Set initial selection visually
            updateToolbarSelection();
        }


        // --- Initialization Function (init - Modified) ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 10, 90);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, groundHeight + playerHeight, 5);

            renderer = new THREE.WebGLRenderer({ antialias: false }); // Turn off AA for sharper pixels maybe?
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xcccccc, 0.9);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(50, 80, 40);
            scene.add(directionalLight);

            controls = new PointerLockControls(camera, document.body);
            scene.add(controls.getObject());

            instructions.addEventListener('click', () => controls.lock());
            controls.addEventListener('lock', () => {
                instructions.style.display = 'none';
                blocker.style.display = 'none';
            });
            controls.addEventListener('unlock', () => {
                blocker.style.display = 'flex';
                instructions.style.display = '';
            });

            // --- Keyboard Input --- (No changes needed here)
            const onKeyDown = (event) => {
                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = true; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                    case 'ArrowRight': case 'KeyD': moveRight = true; break;
                    case 'Space':
                         const playerY = controls.getObject().position.y;
                         const groundCheckY = Math.floor(playerY - playerHeight - 0.1);
                         const groundCheckKey = getVoxelKey(
                             Math.floor(controls.getObject().position.x),
                             groundCheckY,
                             Math.floor(controls.getObject().position.z)
                         );
                         // More robust ground check - allow jump even if slightly above due to float precision
                         const onGround = world[groundCheckKey] || (playerY <= groundHeight + playerHeight + 0.01);
                         if (onGround && velocity.y <= 0) { // Allow jump if on ground and not already moving up significantly
                             velocity.y = jumpVelocity;
                         }
                         break;
                    case 'ShiftLeft': case 'ControlLeft': moveDown = true; break;
                }
            };
             const onKeyUp = (event) => {
                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = false; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                    case 'ArrowRight': case 'KeyD': moveRight = false; break;
                    case 'ShiftLeft': case 'ControlLeft': moveDown = false; break;
                }
            };
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);


            // --- Mouse Input (Block Placement/Removal) --- (No changes needed here)
             window.addEventListener('mousedown', (event) => {
                 if (!controls.isLocked) return;
                 const intersection = getIntersection();
                 if (!intersection) return;

                 // intersection.point is the exact point in 3D space where the click landed
                 // intersection.face.normal is the vector pointing outwards from the clicked face
                 // intersection.object is the mesh that was clicked

                 const obj = intersection.object;
                 const hitCoords = obj.userData; // These are the integer {x, y, z} coords of the hit block

                 // Ensure we actually hit a world block with coordinates
                 if (!hitCoords || typeof hitCoords.x === 'undefined') {
                     console.log("Clicked on non-world object or object missing coords.");
                     return;
                 }

                 const normal = intersection.face.normal;

                 if (event.button === 0) { // Left click - Place block
                     // --- CORRECTED PLACEMENT LOGIC ---
                     // Calculate the integer coordinates of the voxel where the new block should be placed.
                     // We simply add the normal's components (rounded to ensure they are -1, 0, or 1)
                     // to the integer coordinates of the block that was hit.
                     const placeCoords = {
                         x: hitCoords.x + Math.round(normal.x),
                         y: hitCoords.y + Math.round(normal.y),
                         z: hitCoords.z + Math.round(normal.z)
                     };
                     // --- End Corrected Logic ---

                     // --- Player Collision Check (Refined) ---
                     const playerPos = controls.getObject().position;
                     const playerVoxelX = Math.floor(playerPos.x);
                     // Calculate the voxel the player's feet are primarily in
                     const playerVoxelYFeet = Math.floor(playerPos.y - playerHeight + 0.01); // Small epsilon helps with floor rounding
                     // Calculate the voxel the player's head is primarily in
                     const playerVoxelYHead = Math.floor(playerPos.y - 0.1); // Check slightly below camera position
                     const playerVoxelZ = Math.floor(playerPos.z);

                     // Check if the target placement voxel is the same as the player's feet voxel
                     const isAtPlayerFeet = (placeCoords.x === playerVoxelX &&
                                             placeCoords.z === playerVoxelZ &&
                                             placeCoords.y === playerVoxelYFeet);

                     // Check if the target placement voxel is the same as the player's head voxel
                     const isAtPlayerHead = (placeCoords.x === playerVoxelX &&
                                             placeCoords.z === playerVoxelZ &&
                                             placeCoords.y === playerVoxelYHead);
                     // --- End Player Collision Check ---


                     // Place the block if it's not inside the player's occupied voxels
                     if (!isAtPlayerFeet && !isAtPlayerHead) {
                         addVoxel(placeCoords.x, placeCoords.y, placeCoords.z, currentTool);
                     } else {
                         console.log("Cannot place block inside player");
                     }

                 } else if (event.button === 2) { // Right click - Remove block
                    // Removal logic remains the same - uses the coordinates of the block hit
                    removeVoxel(hitCoords.x, hitCoords.y, hitCoords.z);
                 }
             });

            // --- Scroll Wheel Input (NEW) ---
            window.addEventListener('wheel', (event) => {
                if (!controls.isLocked) return; // Only change tool when playing

                event.preventDefault(); // Prevent page scrolling

                const scrollDirection = Math.sign(event.deltaY); // +1 for down/forward, -1 for up/backward

                if (scrollDirection > 0) { // Scroll down -> next tool
                    currentToolIndex++;
                    if (currentToolIndex >= toolTypes.length) {
                        currentToolIndex = 0; // Wrap around to the start
                    }
                } else if (scrollDirection < 0) { // Scroll up -> previous tool
                    currentToolIndex--;
                    if (currentToolIndex < 0) {
                        currentToolIndex = toolTypes.length - 1; // Wrap around to the end
                    }
                }

                // Update the current tool based on the new index
                currentTool = toolTypes[currentToolIndex];
                // Update the visual selection in the toolbar
                updateToolbarSelection();

            }, { passive: false }); // passive: false needed for preventDefault()


            // --- World Generation & UI Setup ---
            generateWorld();
            setupToolbar(); // Now correctly initializes selection

            // --- Add Voxel Outline ---
            scene.add(voxelOutlineMesh);

            // --- Resize Listener ---
            window.addEventListener('resize', onWindowResize);
        }

        // --- Resize Handler (onWindowResize) ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Raycasting Function (getIntersection) ---
         function getIntersection() {
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(objects, false); // Don't check children recursively
             // Filter out the outline mesh itself if it somehow gets intersected
             const validIntersects = intersects.filter(intersect => intersect.object !== voxelOutlineMesh);
             return validIntersects.length > 0 ? validIntersects[0] : null;
         }

        // --- Update Voxel Outline ---
        function updateVoxelOutline() {
             const intersection = getIntersection();
             if (intersection && intersection.object.userData && typeof intersection.object.userData.x !== 'undefined') {
                // Use the intersected block's position directly
                const blockPos = intersection.object.position;
                voxelOutlineMesh.position.copy(blockPos);
                voxelOutlineMesh.visible = true;
             } else {
                 voxelOutlineMesh.visible = false;
             }
        }

        // --- Animation Loop (animate - minor collision refinement) ---
        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = Math.min(0.05, (time - prevTime) / 1000);

             if (controls.isLocked) {
                 velocity.x -= velocity.x * 10.0 * delta;
                 velocity.z -= velocity.z * 10.0 * delta;
                 velocity.y -= gravity * delta;

                 direction.z = Number(moveForward) - Number(moveBackward);
                 direction.x = Number(moveRight) - Number(moveLeft);
                 direction.normalize();

                 const currentSpeed = playerSpeed * delta;
                 if (moveForward || moveBackward) velocity.z -= direction.z * currentSpeed;
                 if (moveLeft || moveRight) velocity.x -= direction.x * currentSpeed;

                 // --- Collision Detection Refined ---
                 const playerPos = controls.getObject().position;
                 const futurePosX = playerPos.x - velocity.x * delta; // Predicted horizontal X pos
                 const futurePosZ = playerPos.z - velocity.z * delta; // Predicted horizontal Z pos
                 const futureFeetY = playerPos.y + velocity.y * delta - playerHeight; // Predicted feet pos
                 const futureHeadY = playerPos.y + velocity.y * delta + 0.1; // Predicted head pos

                 const voxelX = Math.floor(playerPos.x);
                 const voxelZ = Math.floor(playerPos.z);
                 const nextVoxelX = Math.floor(futurePosX);
                 const nextVoxelZ = Math.floor(futurePosZ);
                 const groundVoxelY = Math.floor(futureFeetY); // Voxel below predicted feet
                 const headVoxelY = Math.floor(futureHeadY); // Voxel at predicted head

                 // Ground Collision
                 const groundKey = getVoxelKey(voxelX, groundVoxelY, voxelZ); // Check below current horizontal pos
                 if (velocity.y <= 0 && world[groundKey] && futureFeetY < groundVoxelY + 1) {
                     velocity.y = 0;
                     playerPos.y = groundVoxelY + 1 + playerHeight; // Snap
                 }

                 // Ceiling Collision
                 const headKey = getVoxelKey(voxelX, headVoxelY, voxelZ);
                 if (velocity.y > 0 && world[headKey] && futureHeadY > headVoxelY) {
                     velocity.y = 0;
                     playerPos.y = headVoxelY - 0.15; // Snap below, slight buffer
                 }

                 // --- Horizontal Collision (Very Basic - needs improvement for sliding) ---
                 // Check X direction
                const checkX = (velocity.x < 0 ? Math.floor(futurePosX - 0.3) : Math.floor(futurePosX + 0.3)); // Check slightly ahead in X
                const collisionKeyX1 = getVoxelKey(checkX, Math.floor(playerPos.y - playerHeight + 0.1), voxelZ); // Feet level
                const collisionKeyX2 = getVoxelKey(checkX, Math.floor(playerPos.y - 0.1), voxelZ); // Head level (approx)
                if (world[collisionKeyX1] || world[collisionKeyX2]) {
                    velocity.x = 0;
                }

                // Check Z direction
                const checkZ = (velocity.z < 0 ? Math.floor(futurePosZ - 0.3) : Math.floor(futurePosZ + 0.3)); // Check slightly ahead in Z
                const collisionKeyZ1 = getVoxelKey(voxelX, Math.floor(playerPos.y - playerHeight + 0.1), checkZ); // Feet level
                const collisionKeyZ2 = getVoxelKey(voxelX, Math.floor(playerPos.y - 0.1), checkZ); // Head level (approx)
                 if (world[collisionKeyZ1] || world[collisionKeyZ2]) {
                    velocity.z = 0;
                }


                 // Apply Movement
                 controls.moveRight(-velocity.x * delta);
                 controls.moveForward(-velocity.z * delta);
                 playerPos.y += velocity.y * delta;

                 if (moveDown) playerPos.y -= currentSpeed * 0.5 * delta;

                 if (playerPos.y < playerHeight) {
                     velocity.y = 0;
                     playerPos.y = playerHeight;
                 }

                 updateVoxelOutline();

             } else {
                 velocity.set(0, 0, 0);
                 voxelOutlineMesh.visible = false;
             }

            prevTime = time;
            renderer.render(scene, camera);
        }

    </script>
</body>
</html>
