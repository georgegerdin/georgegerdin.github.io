<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple 3D Block Game (Three.js) - Improved Collision</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #7ec0ee; }
        canvas { display: block; }
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex; /* Use flexbox */
            justify-content: center; /* Center horizontally */
            align-items: center; /* Center vertically */
        }
        #instructions {
            width: 60%;
            background-color: #fff;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
        }
        #crosshair {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 10px; /* Adjusted size */
            height: 1px; /* Line crosshair - horizontal */
            background-color: white;
            transform: translate(-50%, -50%);
            pointer-events: none; /* Don't let it interfere with clicks */
            mix-blend-mode: difference; /* Makes it visible on most backgrounds */
        }
        /* Vertical line for the crosshair */
        #crosshair::after {
            content: '';
            position: absolute;
            left: 50%;
            top: -4.5px; /* Position relative to parent */
            width: 1px;
            height: 10px; /* Match parent width */
            background-color: white;
            transform: translateX(-50%);
            mix-blend-mode: difference;
        }
         #toolbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            background-color: rgba(200, 200, 200, 0.8);
            padding: 5px;
            border-radius: 5px;
            border: 1px solid #555;
            z-index: 10; /* Ensure it's above the canvas */
         }
        .tool-button {
            width: 40px;
            height: 40px;
            border: 2px solid #555;
            cursor: pointer;
            background-size: cover; /* Scale texture nicely */
            image-rendering: pixelated; /* Keep textures blocky */
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            transition: transform 0.1s ease-out, border 0.1s ease-out; /* Smooth transitions */
        }
        .tool-button.selected {
            border: 3px solid #0000ff; /* Blue border for selection */
            transform: scale(1.1); /* Slightly larger when selected */
            box-shadow: 0 0 5px rgba(0, 0, 255, 0.7); /* Optional glow */
        }
        /* Info Display Styles */
        #infoDisplay {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 8px;
            border-radius: 5px;
            font-family: monospace; /* Good for aligning numbers */
            font-size: 12px;
            line-height: 1.4;
            z-index: 5; /* Above canvas, below blocker maybe */
            pointer-events: none; /* Don't capture mouse clicks */
        }
        #infoDisplay span {
            display: inline-block; /* Allows setting width */
            min-width: 35px;      /* Keeps layout stable */
            text-align: right;    /* Align numbers nicely */
            margin-left: 2px;
        }
    </style>
</head>
<body>
    <div id="blocker">
        <div id="instructions">
            <h1>Simple 3D Blocks</h1>
            <p>Click to Play</p>
            <p>(W, A, S, D = Move, SPACE = Jump, MOUSE = Look)</p>
            <p>Left Click = Place Block, Right Click = Remove Block</p>
            <p>SCROLL WHEEL = Change Block Type</p>
             <p style="color: green;">Collision Improved!</p>
        </div>
    </div>

    <div id="crosshair"></div>

    <div id="toolbar">
        <!-- Tool buttons will be populated by JS -->
    </div>

    <!-- Info Display -->
    <div id="infoDisplay">
        <div>FPS:<span id="fpsValue">--</span></div>
        <div>Pos:
            X:<span id="posX">--.--</span>|
            Y:<span id="posY">--.--</span>|
            Z:<span id="posZ">--.--</span>
        </div>
        <div>View:
            Yaw:<span id="viewYaw">--.--</span>°|
            Pitch:<span id="viewPitch">--.--</span>°
        </div>
    </div>

    <!-- Import three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                 "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        let scene, camera, renderer, controls;
        let world = {};
        const objects = []; // Holds meshes for raycasting (blocks)

        const worldWidth = 20;
        const worldDepth = 20;
        const worldHeight = 10; // Max build height
        const groundHeight = 5; // Initial ground level

        // Movement states
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let moveDown = false; // Keep variable but currently disabled in key handlers
        let canJump = false; // Track if player is on ground

        // Physics/Movement variables
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const gravity = 30.0;
        const jumpVelocity = 10.0;
        const playerSpeed = 400.0; // Scaled by delta in movement calculation
        const playerHeight = 1.8; // How tall the player is (eye level to feet)
        const playerWidth = 0.6; // Player bounding box width/depth (less than 1 block)
        const playerHalfWidth = playerWidth / 2;
        const playerHalfDepth = playerWidth / 2; // Assuming square base for simplicity

        // DOM Elements
        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');
        const toolbar = document.getElementById('toolbar');
        let fpsValueSpan, posXSpan, posYSpan, posZSpan, viewYawSpan, viewPitchSpan; // For info display

        // --- Tool Management ---
        const textureUrls = { // URLs for TOOLBAR ICONS (and some mesh textures)
            grass: 'grass.jpg', // Use top view for grass icon
            dirt: 'dirt.jpg',
            stone: 'cobble.jpg',
            wood: 'wood.jpg', // Use top view for wood icon
            leaves: 'leaves.webp',
            sand: 'sand.jpg',
        };
        const toolTypes = Object.keys(textureUrls); // Defines order of tools
        let currentToolIndex = 0; // Start with the first tool
        let currentTool = toolTypes[currentToolIndex]; // Initialize currentTool based on index

        // --- Texture Loading (for 3D Meshes) ---
        const textureLoader = new THREE.TextureLoader();
        const textures = {
            dirt: textureLoader.load(textureUrls.dirt), // Reuse URL
            grass: textureLoader.load('grass.jpg'), // Side texture for mesh (assuming different file or same if side/top same)
            grass_top: textureLoader.load(textureUrls.grass), // Top texture for mesh & icon
            stone: textureLoader.load(textureUrls.stone),
            wood: textureLoader.load('wood.jpg'), // Side texture for mesh
            wood_top: textureLoader.load(textureUrls.wood), // Top texture for mesh & icon
            leaves: textureLoader.load(textureUrls.leaves),
            sand: textureLoader.load(textureUrls.sand),
        };

        // Improve texture appearance (pixelated)
        for (const key in textures) {
            if (textures[key] && textures[key] instanceof THREE.Texture) {
                textures[key].magFilter = THREE.NearestFilter;
                textures[key].minFilter = THREE.NearestFilter;
            }
        }

        // --- Material Definitions ---
         const materials = {
            grass: [ // Multi-material for different faces
                new THREE.MeshLambertMaterial({ map: textures.grass }), // right (+x)
                new THREE.MeshLambertMaterial({ map: textures.grass }), // left (-x)
                new THREE.MeshLambertMaterial({ map: textures.grass_top }), // top (+y)
                new THREE.MeshLambertMaterial({ map: textures.dirt }),    // bottom (-y)
                new THREE.MeshLambertMaterial({ map: textures.grass }), // front (+z)
                new THREE.MeshLambertMaterial({ map: textures.grass }), // back (-z)
            ],
            dirt: new THREE.MeshLambertMaterial({ map: textures.dirt }),
            stone: new THREE.MeshLambertMaterial({ map: textures.stone }),
            wood: [ // Multi-material for logs
                 new THREE.MeshLambertMaterial({ map: textures.wood }), // right
                 new THREE.MeshLambertMaterial({ map: textures.wood }), // left
                 new THREE.MeshLambertMaterial({ map: textures.wood_top }), // top
                 new THREE.MeshLambertMaterial({ map: textures.wood_top }), // bottom
                 new THREE.MeshLambertMaterial({ map: textures.wood }), // front
                 new THREE.MeshLambertMaterial({ map: textures.wood }), // back
            ],
            leaves: new THREE.MeshLambertMaterial({
                 map: textures.leaves,
                 alphaTest: 0.5, // Simple cutout transparency
                 side: THREE.DoubleSide // Render both sides
                }),
            sand: new THREE.MeshLambertMaterial({ map: textures.sand }),
        };


        // --- Raycasting (for block interaction) ---
        const raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, 0, -1), 0, 5); // Limit raycast distance
        const pointer = new THREE.Vector2(0, 0); // Center of screen for raycasting

        // --- Voxel Outline ---
        const voxelOutlineGeometry = new THREE.BoxGeometry(1.01, 1.01, 1.01); // Slightly larger than block
        const voxelOutlineMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true, depthTest: false, transparent: true, opacity: 0.7 });
        const voxelOutlineMesh = new THREE.Mesh(voxelOutlineGeometry, voxelOutlineMaterial);
        voxelOutlineMesh.visible = false;

        // Timing
        let prevTime = performance.now();
        let lastInfoUpdateTime = 0; // Can be used to throttle info updates if needed

        init();
        animate();

        // --- Utility Functions ---
        function getVoxelKey(x, y, z) {
             return `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`;
        }

        // Gets the correct material (single or array) for a block type
        function getMaterial(type) {
             if (type === 'grass') return materials.grass;
             if (type === 'wood') return materials.wood;
             // For single-texture blocks or fallback
             return materials[type] || materials.stone; // Default to stone if specific material undefined
        }


        // --- Voxel Management ---
        function addVoxel(x, y, z, type) {
            x = Math.floor(x); // Ensure integer coordinates
            y = Math.floor(y);
            z = Math.floor(z);
            const key = getVoxelKey(x, y, z);

            // Prevent building outside world bounds or overwriting existing blocks
            if (world[key] || y < 0 || y >= worldHeight) return;

             // Ensure material exists for the type before creating mesh
             let material = getMaterial(type);
             if (!material) {
                 console.warn(`No material found for type: ${type}. Using stone.`);
                 type = 'stone'; // Fallback to stone if material is missing
                 material = materials.stone;
             }

            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const mesh = new THREE.Mesh(geometry, material);

            // Position mesh at the center of the voxel space
            mesh.position.set(x + 0.5, y + 0.5, z + 0.5);
            // Store voxel coordinates and type in userData for later retrieval
            mesh.userData = { x, y, z, type };

            scene.add(mesh);
            objects.push(mesh); // Add to raycasting list
            world[key] = { type: type, mesh: mesh }; // Add to world dictionary
        }

         function removeVoxel(x, y, z) {
            x = Math.floor(x);
            y = Math.floor(y);
            z = Math.floor(z);
            const key = getVoxelKey(x, y, z);
            const voxelData = world[key];

            if (voxelData) {
                scene.remove(voxelData.mesh);
                const index = objects.indexOf(voxelData.mesh);
                if (index > -1) {
                    objects.splice(index, 1); // Remove from raycasting list
                }
                 // Optional: Dispose geometry/material if concerned about memory leaks
                 // voxelData.mesh.geometry.dispose();
                 // (material disposal is more complex if it's an array)
                delete world[key]; // Remove from world dictionary
                return true; // Indicate success
            }
            return false; // Indicate nothing was removed
        }

        // --- World Generation ---
        function generateWorld() {
            // Simple flat world base
            for (let x = -worldWidth / 2; x < worldWidth / 2; x++) {
                for (let z = -worldDepth / 2; z < worldDepth / 2; z++) {
                    for (let y = 0; y < groundHeight; y++) {
                        let type = 'stone';
                         if (y === groundHeight - 1) type = 'grass'; // Top layer grass
                         else if (y >= groundHeight - 3) type = 'dirt'; // Dirt below grass
                         addVoxel(x, y, z, type);
                    }
                }
            }
             // Add simple "trees"
            for (let i = 0; i < 5; i++) { // Add 5 trees
                const treeX = Math.floor(Math.random() * worldWidth - worldWidth / 2);
                const treeZ = Math.floor(Math.random() * worldDepth - worldDepth / 2);
                const treeHeight = 4 + Math.floor(Math.random() * 3); // Random height 4-6 blocks
                const groundKey = getVoxelKey(treeX, groundHeight - 1, treeZ);

                 // Only place tree if the base block is grass
                 if (world[groundKey] && world[groundKey].type === 'grass') {
                     // Trunk
                     for(let y = groundHeight; y < groundHeight + treeHeight; y++) {
                         addVoxel(treeX, y, treeZ, 'wood');
                     }
                     // Leaves (simple cube cluster)
                    const leavesY = groundHeight + treeHeight; // Base Y level for leaves
                    for(let lx = -2; lx <= 2; lx++) { // Iterate in a 5x5 horizontal area
                        for(let lz = -2; lz <= 2; lz++) {
                            for(let ly = 0; ly <= 2; ly++) { // Iterate 3 blocks high
                                // Pruning some leaves for a more rounded shape
                                if (Math.abs(lx) === 2 && Math.abs(lz) === 2) continue; // Skip corners of outer layer
                                if (ly === 2 && (Math.abs(lx) > 1 || Math.abs(lz) > 1)) continue; // Skip outer edges of top layer

                                const currentY = leavesY + ly;
                                const currentX = treeX + lx;
                                const currentZ = treeZ + lz;

                                // Skip the very center bottom block (where trunk ends)
                                if (lx === 0 && lz === 0 && ly < 1) continue;

                                const key = getVoxelKey(currentX, currentY, currentZ);
                                if (!world[key]) { // Only place leaves in empty air blocks
                                     addVoxel(currentX, currentY, currentZ, 'leaves');
                                }
                            }
                        }
                    }
                 }
            }
        }

        // --- Toolbar UI Management ---
        // Updates the visual selection highlight on the toolbar
        function updateToolbarSelection() {
            document.querySelectorAll('#toolbar .tool-button').forEach(btn => {
                btn.classList.remove('selected'); // Remove selected from all
            });
            const selectedButton = document.getElementById(`tool-${currentTool}`);
            if (selectedButton) {
                selectedButton.classList.add('selected'); // Add selected to the current one
            } else {
                 console.error(`Toolbar button not found for type: ${currentTool}`);
            }
        }

        // Creates the toolbar buttons based on toolTypes
        function setupToolbar() {
            toolTypes.forEach(type => {
                const url = textureUrls[type];
                const button = document.createElement('div');
                button.id = `tool-${type}`;
                button.classList.add('tool-button');
                button.dataset.type = type; // Store type for click handler

                if (url) {
                    // Use placeholder images if actual textures aren't available locally
                    // Replace these with actual paths if you have the images
                    const placeholderBase = 'https://via.placeholder.com/40/';
                    const colors = { grass: '009900', dirt: '8B4513', stone: '808080', wood: 'A0522D', leaves: '228B22', sand: 'F4A460' };
                    button.style.backgroundImage = `url(${placeholderBase}${colors[type] || 'CCCCCC'}?text=${type.substring(0,1).toUpperCase()})`; // Simple fallback
                    // For local files (if they exist in the same folder):
                    // button.style.backgroundImage = `url(${url})`;
                } else {
                    // Fallback visual cue if URL is missing
                    button.style.backgroundColor = '#ff00ff'; // Bright pink
                    console.warn(`Missing texture URL for toolbar type: ${type}`);
                }

                // Add click listener to select the tool
                button.addEventListener('click', () => {
                    currentTool = type; // Update tool name
                    currentToolIndex = toolTypes.indexOf(type); // Update index
                    updateToolbarSelection(); // Update visual highlight
                });

                toolbar.appendChild(button); // Add the button to the toolbar div
            });

            // Set initial selection visually after creating all buttons
            updateToolbarSelection();
        }


        // --- NEW: Player AABB Helper ---
        function getPlayerAABB(position) {
            // position.y is the eye level, feet are at position.y - playerHeight
            return new THREE.Box3(
                new THREE.Vector3(position.x - playerHalfWidth, position.y - playerHeight, position.z - playerHalfDepth),
                new THREE.Vector3(position.x + playerHalfWidth, position.y,                position.z + playerHalfDepth)
            );
        }

        // --- NEW: Collision Check Function ---
        function checkCollision(playerPos) {
            const playerAABB = getPlayerAABB(playerPos);
            // Determine the range of world voxels the player AABB *might* overlap with
            const minX = Math.floor(playerAABB.min.x);
            const maxX = Math.floor(playerAABB.max.x);
            const minY = Math.floor(playerAABB.min.y);
            const maxY = Math.floor(playerAABB.max.y);
            const minZ = Math.floor(playerAABB.min.z);
            const maxZ = Math.floor(playerAABB.max.z);

            // Iterate only through the potentially overlapping voxels
            for (let x = minX; x <= maxX; x++) {
                for (let y = minY; y <= maxY; y++) {
                    for (let z = minZ; z <= maxZ; z++) {
                        const key = getVoxelKey(x, y, z);
                        if (world[key]) {
                            // Create a bounding box for the world block
                            const blockAABB = new THREE.Box3(
                                new THREE.Vector3(x, y, z),
                                new THREE.Vector3(x + 1, y + 1, z + 1)
                            );
                            // Check if the player's AABB actually intersects this block's AABB
                            if (playerAABB.intersectsBox(blockAABB)) {
                                return true; // Collision detected
                            }
                        }
                    }
                }
            }
            return false; // No collision found within the potential range
        }


        // --- Initialization Function ---
        function init() {
            // --- Scene ---
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb); // Sky blue
            scene.fog = new THREE.Fog(0x87ceeb, 10, 90); // Fog matches background

            // --- Camera ---
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100); // Near/Far planes
            // Start player slightly higher to avoid initial ground collision issues
            camera.position.set(0, groundHeight + playerHeight + 0.5, 5);

            // --- Renderer ---
            renderer = new THREE.WebGLRenderer({ antialias: false }); // Set true for smoother edges (potential performance cost)
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio); // Adjust for high-DPI screens
            document.body.appendChild(renderer.domElement);

            // --- Lighting ---
            const ambientLight = new THREE.AmbientLight(0xcccccc, 0.9); // Soft ambient light
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // Sun light
            directionalLight.position.set(50, 80, 40); // Angle the sun
            scene.add(directionalLight);

             // --- Controls (Pointer Lock) ---
            controls = new PointerLockControls(camera, document.body);
            scene.add(controls.getObject()); // Add the controls object (which contains the camera) to the scene

            // Lock pointer on instruction click
            instructions.addEventListener('click', () => controls.lock());

            // Handle locking/unlocking the cursor
            controls.addEventListener('lock', () => {
                instructions.style.display = 'none';
                blocker.style.display = 'none';
            });
            controls.addEventListener('unlock', () => {
                blocker.style.display = 'flex'; // Use flex to keep centering
                instructions.style.display = ''; // Show instructions again
            });

             // --- Keyboard Input ---
            const onKeyDown = (event) => {
                 if (event.repeat) return; // Prevent holding key triggering multiple jumps etc.
                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = true; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                    case 'ArrowRight': case 'KeyD': moveRight = true; break;
                    case 'Space':
                         if (canJump) { // Use the canJump flag set by physics
                             velocity.y = jumpVelocity;
                             canJump = false; // Prevent double jump until next ground contact
                         }
                         break;
                    // case 'ShiftLeft': case 'ControlLeft': moveDown = true; break; // Disabled for now
                }
            };
             const onKeyUp = (event) => {
                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = false; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                    case 'ArrowRight': case 'KeyD': moveRight = false; break;
                    // case 'ShiftLeft': case 'ControlLeft': moveDown = false; break; // Disabled for now
                }
            };
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);


            // --- Mouse Input (Block Placement/Removal) ---
             window.addEventListener('mousedown', (event) => {
                 if (!controls.isLocked) return; // Only interact when playing
                 const intersection = getIntersection();
                 if (!intersection) return; // No block intersected

                 const obj = intersection.object;
                 const hitCoords = obj.userData; // Get {x, y, z} of the clicked block

                 // Ensure we clicked a valid world block with coordinates
                 if (!hitCoords || typeof hitCoords.x === 'undefined') {
                     console.log("Clicked on non-world object or object missing coords.");
                     return;
                 }

                 const normal = intersection.face.normal.clone(); // Use the normal of the face clicked

                 if (event.button === 0) { // Left click - Place block
                     // Calculate integer coords of the adjacent voxel using the face normal
                     const placeCoords = {
                         x: hitCoords.x + normal.x,
                         y: hitCoords.y + normal.y,
                         z: hitCoords.z + normal.z
                     };

                     // --- Player Collision Check (using AABB) ---
                     // Create an AABB for the block we intend to place
                     const blockAABB = new THREE.Box3(
                         new THREE.Vector3(placeCoords.x, placeCoords.y, placeCoords.z),
                         new THREE.Vector3(placeCoords.x + 1, placeCoords.y + 1, placeCoords.z + 1)
                     );
                     // Get the player's current AABB
                     const playerAABB = getPlayerAABB(controls.getObject().position);

                     // Check if the new block would intersect the player
                     if (!playerAABB.intersectsBox(blockAABB)) {
                         addVoxel(placeCoords.x, placeCoords.y, placeCoords.z, currentTool);
                     } else {
                         console.log("Cannot place block inside player");
                         // Maybe provide user feedback here? Sound effect? Message?
                     }

                 } else if (event.button === 2) { // Right click - Remove block
                    // Remove the block that was clicked
                    removeVoxel(hitCoords.x, hitCoords.y, hitCoords.z);
                 }
             });

            // --- Scroll Wheel Input (Tool Switching) ---
            window.addEventListener('wheel', (event) => {
                if (!controls.isLocked) return; // Only change tool when playing

                event.preventDefault(); // Prevent page scrolling

                const scrollDirection = Math.sign(event.deltaY); // +1 for down/forward, -1 for up/backward

                if (scrollDirection > 0) { // Scroll down -> next tool
                    currentToolIndex++;
                    if (currentToolIndex >= toolTypes.length) {
                        currentToolIndex = 0; // Wrap around to the start
                    }
                } else if (scrollDirection < 0) { // Scroll up -> previous tool
                    currentToolIndex--;
                    if (currentToolIndex < 0) {
                        currentToolIndex = toolTypes.length - 1; // Wrap around to the end
                    }
                }

                currentTool = toolTypes[currentToolIndex]; // Update tool name
                updateToolbarSelection(); // Update toolbar highlight

            }, { passive: false }); // Required for preventDefault() on wheel events


            // --- Get References to Info Display Elements ---
            fpsValueSpan = document.getElementById('fpsValue');
            posXSpan = document.getElementById('posX');
            posYSpan = document.getElementById('posY');
            posZSpan = document.getElementById('posZ');
            viewYawSpan = document.getElementById('viewYaw');
            viewPitchSpan = document.getElementById('viewPitch');

            // --- World Generation & UI Setup ---
            generateWorld();
            setupToolbar(); // Create toolbar buttons

            // --- Add Voxel Outline to Scene ---
            scene.add(voxelOutlineMesh);

            // --- Window Resize Listener ---
            window.addEventListener('resize', onWindowResize);
        }

        // --- Resize Handler ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Raycasting Function ---
         function getIntersection() {
            raycaster.setFromCamera(pointer, camera); // Cast ray from camera center
            const intersects = raycaster.intersectObjects(objects, false); // Check against block meshes
             // Filter out the outline mesh itself if it somehow gets intersected
             const validIntersects = intersects.filter(intersect => intersect.object !== voxelOutlineMesh);
             return validIntersects.length > 0 ? validIntersects[0] : null; // Return closest valid intersection
         }

        // --- Update Voxel Outline Position/Visibility ---
        function updateVoxelOutline() {
             const intersection = getIntersection();
             // Check if we hit a valid block with coordinates
             if (intersection && intersection.object.userData && typeof intersection.object.userData.x !== 'undefined') {
                const blockPos = intersection.object.position; // Center position of the hit block
                voxelOutlineMesh.position.copy(blockPos); // Move outline to match
                voxelOutlineMesh.visible = true;
             } else {
                 voxelOutlineMesh.visible = false; // Hide if not looking at a block
             }
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = Math.max(0.0001, Math.min(0.05, (time - prevTime) / 1000));
            prevTime = time;

            // --- Info Display Update (Reads directly from controls/camera for display) ---
            const fps = 1 / delta;
            const displayPos = controls.getObject().position; // Use camera pos for display
            const playerRot = controls.getObject().rotation;
            const yawDeg = THREE.MathUtils.radToDeg(playerRot.y);
            const pitchDeg = THREE.MathUtils.radToDeg(playerRot.x);
            fpsValueSpan.textContent = Math.round(fps);
            posXSpan.textContent = displayPos.x.toFixed(2);
            posYSpan.textContent = displayPos.y.toFixed(2);
            posZSpan.textContent = displayPos.z.toFixed(2);
            viewYawSpan.textContent = ((yawDeg % 360 + 360) % 360).toFixed(1);
            viewPitchSpan.textContent = pitchDeg.toFixed(1);
            // --- End Info Display Update ---
/*
             if (controls.isLocked) {
                // Use playerState for physics simulation
                const currentPos = playerState.position;
                const currentVel = playerState.velocity;

                // --- Apply Damping & Gravity to velocity ---
                currentVel.x -= currentVel.x * 10.0 * delta;
                currentVel.z -= currentVel.z * 10.0 * delta;
                currentVel.y -= gravity * delta;

                // --- Calculate Input Direction Vector ---
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                // --- Calculate World-Space Movement Delta based on Input & Camera Direction ---
                const moveSpeed = playerSpeed * delta;
                const moveDelta = new THREE.Vector3(); // Displacement for this frame based on input

                if (direction.lengthSq() > 0.001) { // Only calculate if there's input
                    const forward = new THREE.Vector3();
                    controls.getDirection(forward); // Get camera direction
                    forward.y = 0;
                    forward.normalize();

                    const right = new THREE.Vector3();
                    right.crossVectors(controls.getObject().up, forward).normalize();

                    if (direction.z !== 0) {
                        moveDelta.addScaledVector(forward, direction.z * moveSpeed);
                    }
                    if (direction.x !== 0) {
                        moveDelta.addScaledVector(right, direction.x * moveSpeed);
                    }
                }

                // --- Calculate total potential displacement for this frame ---
                const totalDelta = new THREE.Vector3();
                totalDelta.add(moveDelta); // Input movement
                totalDelta.addScaledVector(currentVel, delta); // Movement from velocity

                // --- Collision Detection & Resolution (Axis-by-Axis AABB) ---
                // Operate on temporary next position derived from playerState
                const tempPos = new THREE.Vector3(); // Reusable vector for checks
                let finalPosition = currentPos.clone(); // Start with current position

                // --- 1. Resolve X-axis Collision ---
                tempPos.set(finalPosition.x + totalDelta.x, finalPosition.y, finalPosition.z);
                if (!checkCollision(tempPos)) {
                    finalPosition.x += totalDelta.x; // Apply X movement if no collision
                } else {
                    currentVel.x = 0; // Stop X velocity on collision
                }

                // --- 2. Resolve Z-axis Collision ---
                // IMPORTANT: Check Z using the potentially updated X from previous step is complex here.
                // Instead, check Z based on the *original* potential X to simplify.
                // A more advanced solver might iterate, but this is usually sufficient.
                // Check using the final X position after X-resolution
                tempPos.set(finalPosition.x, finalPosition.y, finalPosition.z + totalDelta.z);
                if (!checkCollision(tempPos)) {
                    finalPosition.z += totalDelta.z; // Apply Z movement if no collision
                } else {
                    currentVel.z = 0; // Stop Z velocity on collision
                }

                // --- 3. Resolve Y-axis Collision ---
                 isOnGround = false; // Reset ground status
                 canJump = false; // Assume cannot jump

                tempPos.set(finalPosition.x, finalPosition.y + totalDelta.y, finalPosition.z);
                if (!checkCollision(tempPos)) {
                    // No Y collision - apply the calculated vertical movement
                     finalPosition.y += totalDelta.y;
                } else {
                     // Collision on Y axis
                     if (totalDelta.y < 0) { // Moving down - hit ground
                        // Snap to ground more accurately
                        const checkYBelow = Math.floor(tempPos.y - playerHeight); // Check integer coord below potential feet
                        const checkMinX = Math.floor(finalPosition.x - playerHalfWidth);
                        const checkMaxX = Math.floor(finalPosition.x + playerHalfWidth);
                        const checkMinZ = Math.floor(finalPosition.z - playerHalfDepth);
                        const checkMaxZ = Math.floor(finalPosition.z + playerHalfDepth);

                        let highestGroundY = -Infinity;
                        for (let cx = checkMinX; cx <= checkMaxX; cx++) {
                            for (let cz = checkMinZ; cz <= checkMaxZ; cz++) {
                                const key = getVoxelKey(cx, checkYBelow, cz);
                                if (world[key]) {
                                    highestGroundY = Math.max(highestGroundY, checkYBelow + 1);
                                }
                            }
                        }

                        if (highestGroundY > -Infinity) {
                             finalPosition.y = highestGroundY + playerHeight; // Snap feet exactly
                             isOnGround = true;
                             canJump = true;
                        } else {
                             // Collision detected, but no ground found directly below? Weird state. Keep current Y?
                             // finalPosition.y = currentPos.y; // Or just don't change Y
                        }
                        currentVel.y = 0; // Stop falling velocity

                     } else if (totalDelta.y > 0) { // Moving up - hit ceiling
                         // Snap to ceiling more accurately
                        const checkYAbove = Math.floor(tempPos.y); // Check integer coord at potential head level
                        const checkMinX = Math.floor(finalPosition.x - playerHalfWidth);
                        const checkMaxX = Math.floor(finalPosition.x + playerHalfWidth);
                        const checkMinZ = Math.floor(finalPosition.z - playerHalfDepth);
                        const checkMaxZ = Math.floor(finalPosition.z + playerHalfDepth);

                        let lowestCeilingY = Infinity;
                         for (let cx = checkMinX; cx <= checkMaxX; cx++) {
                             for (let cz = checkMinZ; cz <= checkMaxZ; cz++) {
                                 const key = getVoxelKey(cx, checkYAbove, cz);
                                 if (world[key]) {
                                     lowestCeilingY = Math.min(lowestCeilingY, checkYAbove);
                                 }
                             }
                         }

                         if (lowestCeilingY < Infinity) {
                              finalPosition.y = lowestCeilingY - 0.01; // Snap head just below
                         } else {
                             // Collision detected, but no ceiling found directly above?
                             // finalPosition.y = currentPos.y; // Or just don't change Y
                         }
                         currentVel.y = 0; // Stop rising velocity
                     }
                }


                // --- Update the actual player state ---
                playerState.position.copy(finalPosition);
                // playerState.velocity is already updated

                // --- Prevent falling through the void ---
                if (playerState.position.y < -20) {
                    console.log("Fell out of world, resetting position.");
                    playerState.position.set(0, groundHeight + playerHeight + 5, 0);
                    playerState.velocity.set(0,0,0);
                    canJump = false;
                }

                // --- CRITICAL STEP: Update Controls/Camera position ---
                controls.getObject().position.copy(playerState.position);

                // Update the voxel outline
                updateVoxelOutline();

             } else {
                 // Reset physics velocity if paused
                 playerState.velocity.set(0, 0, 0);
                 canJump = false;
                 voxelOutlineMesh.visible = false;
             }
*/
            // Render the scene (camera position is updated now)
            renderer.render(scene, camera);
        }

    </script>
</body>
</html>
