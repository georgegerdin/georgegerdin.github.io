<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple 3D Block Game - Chunked Entities!</title> <!-- Changed Title -->
    <style>
        /* --- Styles remain the same as before --- */
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #7ec0ee; }
        canvas { display: block; }
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex; /* Use flexbox */
            justify-content: center; /* Center horizontally */
            align-items: center; /* Center vertically */
        }
        #instructions {
            width: 60%;
            background-color: #fff;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
        }
        #crosshair {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 10px; /* Adjusted size */
            height: 1px; /* Line crosshair - horizontal */
            background-color: white;
            transform: translate(-50%, -50%);
            pointer-events: none; /* Don't let it interfere with clicks */
            mix-blend-mode: difference; /* Makes it visible on most backgrounds */
        }
        /* Vertical line for the crosshair */
        #crosshair::after {
            content: '';
            position: absolute;
            left: 50%;
            top: -4.5px; /* Position relative to parent */
            width: 1px;
            height: 10px; /* Match parent width */
            background-color: white;
            transform: translateX(-50%);
            mix-blend-mode: difference;
        }
         #toolbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            background-color: rgba(200, 200, 200, 0.8);
            padding: 5px;
            border-radius: 5px;
            border: 1px solid #555;
            z-index: 10; /* Ensure it's above the canvas */
         }
        .tool-button {
            width: 40px;
            height: 40px;
            border: 2px solid #555;
            cursor: pointer;
            background-size: cover; /* Scale texture nicely */
            image-rendering: pixelated; /* Keep textures blocky */
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            transition: transform 0.1s ease-out, border 0.1s ease-out; /* Smooth transitions */
        }
        .tool-button.selected {
            border: 3px solid #0000ff; /* Blue border for selection */
            transform: scale(1.1); /* Slightly larger when selected */
            box-shadow: 0 0 5px rgba(0, 0, 255, 0.7); /* Optional glow */
        }
        /* Info Display Styles */
        #infoDisplay {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 8px;
            border-radius: 5px;
            font-family: monospace; /* Good for aligning numbers */
            font-size: 12px;
            line-height: 1.4;
            z-index: 5; /* Above canvas, below blocker maybe */
            pointer-events: none; /* Don't capture mouse clicks */
        }
        #infoDisplay span {
            display: inline-block; /* Allows setting width */
            min-width: 35px;      /* Keeps layout stable */
            text-align: right;    /* Align numbers nicely */
            margin-left: 2px;
        }
         #infoDisplay div:last-child { /* Target the Entities line */
            margin-top: 5px;
         }
    </style>
</head>
<body>
    <div id="blocker">
        <div id="instructions">
            <h1>Simple 3D Blocks - Chunked Entities!</h1> <!-- Updated Title -->
            <p>Click to Play</p>
            <p>(W, A, S, D = Move, SPACE = Jump, MOUSE = Look)</p>
            <p>Left Click = Place Block, Right Click = Remove Block</p>
            <p>SCROLL WHEEL = Change Block Type</p>
            <p style="color: green;">Chickens (Entities) are now managed per-chunk!</p> <!-- Updated Desc -->
        </div>
    </div>

    <div id="crosshair"></div>

    <div id="toolbar">
        <!-- Tool buttons will be populated by JS -->
    </div>

    <!-- Info Display -->
    <div id="infoDisplay">
        <div>FPS:<span id="fpsValue">--</span></div>
        <div>Pos:
            X:<span id="posX">--.--</span>|
            Y:<span id="posY">--.--</span>|
            Z:<span id="posZ">--.--</span>
        </div>
        <div>View:
            Yaw:<span id="viewYaw">--.--</span>°|
            Pitch:<span id="viewPitch">--.--</span>°
        </div>
        <div>Chunk: <span id="chunkCoords">--,--,--</span></div>
        <div>Active Entities: <span id="activeEntitiesCount">--</span></div> <!-- Added Entity Count -->
    </div>

    <!-- Import three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                 "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        let scene, camera, renderer, controls;
        let world = {}; // Will store chunks: { "cx,cy,cz": Chunk }
        const objects = []; // Holds meshes for raycasting (all blocks)

        // --- Chunk Configuration ---
        const chunkSize = 16;
        const entityUpdateRadius = 2; // Update entities in chunks within this distance (radius) from player's chunk

        // --- World Dimensions (in blocks, used for generation bounds) ---
        const worldWidth = 20;
        const worldDepth = 20;
        const worldHeight = 10; // Max build height (relative to y=0)
        const groundHeight = 5; // Initial ground level (y-coordinate)

        // Movement states
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let moveDown = false; // Note: This isn't used for movement, might remove later
        let canJump = false;

        // Physics/Movement variables
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const gravity = 30.0;
        const jumpVelocity = 10.0;
        const playerSpeed = 400.0;
        const playerHeight = 1.8;
        const playerWidth = 0.6;
        const playerHalfWidth = playerWidth / 2;
        const playerHalfDepth = playerWidth / 2;

        // DOM Elements
        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');
        const toolbar = document.getElementById('toolbar');
        let fpsValueSpan, posXSpan, posYSpan, posZSpan, viewYawSpan, viewPitchSpan, chunkCoordsSpan, activeEntitiesCountSpan; // Added entity count span

        // --- Tool Management ---
        const textureUrls = {
            grass: 'grass.jpg', dirt: 'dirt.jpg', stone: 'cobble.jpg',
            wood: 'wood.jpg', leaves: 'leaves.webp', sand: 'sand.png',
        };
        

        const toolTypes = Object.keys(textureUrls);
        let currentToolIndex = 0;
        let currentTool = toolTypes[currentToolIndex];

        // --- Texture Loading ---
        const textureLoader = new THREE.TextureLoader();
        const textures = {
            dirt: textureLoader.load(textureUrls.dirt),
            grass: textureLoader.load(textureUrls.grass), // Side texture
            grass_top: textureLoader.load(textureUrls.grass), // Top texture (reuse side for now)
            stone: textureLoader.load(textureUrls.stone),
            wood: textureLoader.load(textureUrls.wood), // Side texture
            wood_top: textureLoader.load(textureUrls.wood), // Top/Bottom texture (reuse side for now)
            leaves: textureLoader.load(textureUrls.leaves),
            sand: textureLoader.load(textureUrls.sand),
        };
        // Apply nearest neighbor filtering for pixelated look
        for (const key in textures) {
            if (textures[key] instanceof THREE.Texture) {
                textures[key].magFilter = THREE.NearestFilter;
                textures[key].minFilter = THREE.NearestFilter;
            }
        }
        
        textures.leaves.transparent = true; // Enable transparency for leaves if using alpha


        // --- Material Definitions ---
         const materials = {
            grass: [
                new THREE.MeshLambertMaterial({ map: textures.grass }), // right
                new THREE.MeshLambertMaterial({ map: textures.grass }), // left
                new THREE.MeshLambertMaterial({ map: textures.grass_top }), // top
                new THREE.MeshLambertMaterial({ map: textures.dirt }), // bottom
                new THREE.MeshLambertMaterial({ map: textures.grass }), // front
                new THREE.MeshLambertMaterial({ map: textures.grass }), // back
            ],
            dirt: new THREE.MeshLambertMaterial({ map: textures.dirt }),
            stone: new THREE.MeshLambertMaterial({ map: textures.stone }),
            wood: [
                 new THREE.MeshLambertMaterial({ map: textures.wood }), // sides
                 new THREE.MeshLambertMaterial({ map: textures.wood }),
                 new THREE.MeshLambertMaterial({ map: textures.wood_top }), // top/bottom
                 new THREE.MeshLambertMaterial({ map: textures.wood_top }),
                 new THREE.MeshLambertMaterial({ map: textures.wood }),
                 new THREE.MeshLambertMaterial({ map: textures.wood }),
            ],
            // Make leaves slightly transparent and visible from both sides
            leaves: new THREE.MeshLambertMaterial({
                map: textures.leaves,
                alphaTest: 0.1, // Adjust this value if needed (0 to 1)
                transparent: true,
                side: THREE.DoubleSide // Render both faces
             }),
            sand: new THREE.MeshLambertMaterial({ map: textures.sand }),
        };

        // --- Raycasting ---
        const raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, 0, -1), 0, 5);
        const pointer = new THREE.Vector2(0, 0); // Center of the screen

        // --- Face Outline ---
        const faceOutlineGeometry = new THREE.PlaneGeometry(1, 1);
        const faceOutlineMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide, transparent: true, opacity: 0.4, depthTest: false });
        const faceOutlineMesh = new THREE.Mesh(faceOutlineGeometry, faceOutlineMaterial);
        faceOutlineMesh.visible = false;

        // --- Chunk Outline Material ---
        const chunkOutlineMaterial = new THREE.LineBasicMaterial({
            color: 0xff0000, // Red color for outlines
            depthTest: true // Draw outlines normally
        });

        // --- Entity Configuration (Chicken) ---
        const chickenRadius = 0.3;
        const chickenHeight = chickenRadius * 2;
        const chickenSpeed = 2.0;
        const chickenWalkCycleDuration = 3.0;
        const fallDeathY = -20;

        // --- Chicken Visuals (shared) ---
        const chickenGeometry = new THREE.SphereGeometry(chickenRadius, 8, 6);
        const chickenMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });

        // Timing
        let prevTime = performance.now();
        let totalActiveEntities = 0; // Counter for display

        // ===============================================================
        // ===== CHUNK CLASS DEFINITION (with Entity Storage) ============
        // ===============================================================
        class Chunk {
            constructor(chunkX, chunkY, chunkZ) {
                this.chunkX = chunkX;
                this.chunkY = chunkY;
                this.chunkZ = chunkZ;
                this.chunkKey = getChunkKey(chunkX, chunkY, chunkZ); // Store key for easy access
                this.worldOrigin = new THREE.Vector3(
                    chunkX * chunkSize, chunkY * chunkSize, chunkZ * chunkSize
                );
                this.voxels = this.initVoxels(); // Voxel data { type, mesh }
                this.entities = new Set(); // *** Stores entities currently in this chunk ***
                this.outlineMesh = this.createOutlineMesh();
                scene.add(this.outlineMesh);
            }

            initVoxels() {
                const arr = new Array(chunkSize).fill(null).map(() =>
                    new Array(chunkSize).fill(null).map(() =>
                        new Array(chunkSize).fill(null)
                    )
                );
                return arr;
            }

             createOutlineMesh() {
                const geometry = new THREE.BoxGeometry(chunkSize, chunkSize, chunkSize);
                const edges = new THREE.EdgesGeometry(geometry);
                const line = new THREE.LineSegments(edges, chunkOutlineMaterial);
                line.position.set(
                    this.worldOrigin.x + chunkSize / 2,
                    this.worldOrigin.y + chunkSize / 2,
                    this.worldOrigin.z + chunkSize / 2
                );
                line.userData.isChunkOutline = true;
                return line;
            }

            // Get voxel data at LOCAL coordinates (0 to chunkSize-1)
            getVoxel(localX, localY, localZ) {
                 if (this.isValidLocalCoord(localX, localY, localZ)) {
                     return this.voxels[localX][localY][localZ];
                 }
                 return null;
            }

            // Set voxel data at LOCAL coordinates
            setVoxel(localX, localY, localZ, voxelData) {
                 if (this.isValidLocalCoord(localX, localY, localZ)) {
                    this.voxels[localX][localY][localZ] = voxelData;
                    return true;
                 }
                 return false;
            }

             // Check if local coordinates are within the chunk bounds
            isValidLocalCoord(lx, ly, lz) {
                return lx >= 0 && lx < chunkSize && ly >= 0 && ly < chunkSize && lz >= 0 && lz < chunkSize;
            }

            // Convert WORLD coordinates to LOCAL chunk coordinates
            worldToLocal(worldX, worldY, worldZ) {
                const localX = THREE.MathUtils.euclideanModulo(Math.floor(worldX), chunkSize);
                const localY = THREE.MathUtils.euclideanModulo(Math.floor(worldY), chunkSize);
                const localZ = THREE.MathUtils.euclideanModulo(Math.floor(worldZ), chunkSize);
                return { x: localX, y: localY, z: localZ };
            }

            // Convert LOCAL chunk coordinates to WORLD coordinates
            localToWorld(localX, localY, localZ) {
                return { x: this.worldOrigin.x + localX, y: this.worldOrigin.y + localY, z: this.worldOrigin.z + localZ };
            }

            // *** Add Entity to this Chunk ***
            addEntity(entity) {
                this.entities.add(entity);
                // console.log(`Added entity ${entity.constructor.name} to chunk ${this.chunkKey}`);
            }

            // *** Remove Entity from this Chunk ***
            removeEntity(entity) {
                this.entities.delete(entity);
                // console.log(`Removed entity ${entity.constructor.name} from chunk ${this.chunkKey}`);
            }

            dispose() {
                // Dispose outline
                if (this.outlineMesh) {
                    scene.remove(this.outlineMesh);
                    this.outlineMesh.geometry.dispose();
                }
                // Dispose voxels
                for (let x = 0; x < chunkSize; x++) {
                    for (let y = 0; y < chunkSize; y++) {
                        for (let z = 0; z < chunkSize; z++) {
                            const voxelData = this.voxels[x][y][z];
                            if (voxelData && voxelData.mesh) {
                                // Mesh should already be removed from scene by removeVoxel
                                voxelData.mesh.geometry.dispose();
                            }
                        }
                    }
                }
                // *** Dispose entities within this chunk ***
                // Iterate over a copy because entity.dispose() might modify the set via removeEntity
                const entitiesToDispose = Array.from(this.entities);
                entitiesToDispose.forEach(entity => {
                    entity.dispose(); // Entity's dispose handles scene removal and self-removal from chunk
                });
                this.entities.clear(); // Clear the set itself

                 console.log(`Disposed chunk ${this.chunkKey}`);
            }
        }
        // ===============================================================
        // ===== END CHUNK CLASS =========================================
        // ===============================================================


        // --- Chunk Utility Functions ---

        function getChunkCoords(worldX, worldY, worldZ) {
            const cx = Math.floor(worldX / chunkSize);
            const cy = Math.floor(worldY / chunkSize);
            const cz = Math.floor(worldZ / chunkSize);
            return { x: cx, y: cy, z: cz };
        }

        function getChunkKey(chunkX, chunkY, chunkZ) {
            // Can accept coords object or individual coords
            if (typeof chunkX === 'object') {
                return `${chunkX.x},${chunkX.y},${chunkX.z}`;
            }
            return `${chunkX},${chunkY},${chunkZ}`;
        }

        // Get the Chunk object. Creates chunk (and its outline) if it doesn't exist.
        function getChunk(worldX, worldY, worldZ) {
            const coords = (typeof worldX === 'object') ? worldX : getChunkCoords(worldX, worldY, worldZ);
            const key = getChunkKey(coords.x, coords.y, coords.z);
            if (!world[key]) {
                // console.log(`Creating chunk at ${key}`);
                world[key] = new Chunk(coords.x, coords.y, coords.z);
            }
            return world[key];
        }

        function getVoxelDataFromWorld(worldX, worldY, worldZ) {
             const chunk = getChunk(worldX, worldY, worldZ); // Gets or creates chunk
             if (chunk) {
                 const localCoords = chunk.worldToLocal(worldX, worldY, worldZ);
                 if (chunk.isValidLocalCoord(localCoords.x, localCoords.y, localCoords.z)) {
                    return chunk.getVoxel(localCoords.x, localCoords.y, localCoords.z);
                 }
             }
            return null; // Voxel doesn't exist or coords are out of any loaded chunk range
        }


        // --- Utility Functions ---
        function getMaterial(type) {
             if (type === 'grass') return materials.grass;
             if (type === 'wood') return materials.wood;
             // For single-texture blocks or if array not found
             return materials[type] || materials.stone;
        }


        // --- Voxel Management (CHUNK-AWARE) ---
        function addVoxel(worldX, worldY, worldZ, type) {
            worldX = Math.floor(worldX);
            worldY = Math.floor(worldY);
            worldZ = Math.floor(worldZ);

            // Check if voxel already exists or trying to build outside reasonable limits
            const existingVoxel = getVoxelDataFromWorld(worldX, worldY, worldZ);
            const practicalMaxHeight = worldHeight * chunkSize * 2;
            if (existingVoxel || worldY < 0 || worldY >= practicalMaxHeight ) return;

            const chunk = getChunk(worldX, worldY, worldZ);
            const localCoords = chunk.worldToLocal(worldX, worldY, worldZ);
            let material = getMaterial(type);
             if (!material) { type = 'stone'; material = materials.stone; }

            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(worldX + 0.5, worldY + 0.5, worldZ + 0.5);
            mesh.userData = { x: worldX, y: worldY, z: worldZ, type: type, isVoxel: true };

            scene.add(mesh);
            objects.push(mesh); // Add to raycasting list

            chunk.setVoxel(localCoords.x, localCoords.y, localCoords.z, { type: type, mesh: mesh });
        }

         function removeVoxel(worldX, worldY, worldZ) {
            worldX = Math.floor(worldX);
            worldY = Math.floor(worldY);
            worldZ = Math.floor(worldZ);

            const { x: cx, y: cy, z: cz } = getChunkCoords(worldX, worldY, worldZ);
            const key = getChunkKey(cx, cy, cz);
            const chunk = world[key];
            if (!chunk) return false;

            const localCoords = chunk.worldToLocal(worldX, worldY, worldZ);
            const voxelData = chunk.getVoxel(localCoords.x, localCoords.y, localCoords.z);

            if (voxelData && voxelData.mesh) {
                scene.remove(voxelData.mesh);
                const index = objects.indexOf(voxelData.mesh);
                if (index > -1) objects.splice(index, 1);
                voxelData.mesh.geometry.dispose();
                chunk.setVoxel(localCoords.x, localCoords.y, localCoords.z, null);
                return true;
            }
            return false;
        }

        // --- World Generation ---
        function generateWorld() {
            console.log("Generating world...")
            for (let x = -worldWidth / 2; x < worldWidth / 2; x++) {
                for (let z = -worldDepth / 2; z < worldDepth / 2; z++) {
                    for (let y = 0; y < groundHeight; y++) {
                        let type = (y === groundHeight - 1) ? 'grass' : (y >= groundHeight - 3 ? 'dirt' : 'stone');
                        addVoxel(x, y, z, type);
                    }
                }
            }
            // Generate some simple trees
            for (let i = 0; i < 5; i++) { // Add 5 trees
                // Find a random spot on the generated ground
                const treeX = Math.floor(Math.random() * worldWidth - worldWidth / 2);
                const treeZ = Math.floor(Math.random() * worldDepth - worldDepth / 2);
                const treeHeight = 4 + Math.floor(Math.random() * 3); // Random height 4-6 blocks

                 // Check if the base block is grass before planting
                const baseVoxelData = getVoxelDataFromWorld(treeX, groundHeight - 1, treeZ);
                 if (baseVoxelData && baseVoxelData.type === 'grass') {
                     // Build trunk
                     for(let y = groundHeight; y < groundHeight + treeHeight; y++) {
                         addVoxel(treeX, y, treeZ, 'wood');
                     }
                    // Add leaves canopy
                    const leavesY = groundHeight + treeHeight; // Base height of leaves
                    for(let lx = -2; lx <= 2; lx++) { // 5x5 area
                        for(let lz = -2; lz <= 2; lz++) {
                            for(let ly = 0; ly <= 2; ly++) { // 3 blocks high
                                // Simple leaf shape: skip corners of outer layer and center bottom
                                if (Math.abs(lx) === 2 && Math.abs(lz) === 2) continue; // Skip outer corners
                                if (ly === 2 && (Math.abs(lx) > 1 || Math.abs(lz) > 1)) continue; // Taper top layer
                                const currentY = leavesY + ly;
                                const currentX = treeX + lx;
                                const currentZ = treeZ + lz;
                                // Don't replace trunk or existing blocks
                                if (lx === 0 && lz === 0 && ly < 1) continue; // Don't put leaves inside top of trunk
                                if (!getVoxelDataFromWorld(currentX, currentY, currentZ)) { // Only place if empty
                                     addVoxel(currentX, currentY, currentZ, 'leaves');
                                }
                            }
                        }
                    }
                 }
            }
            console.log("World generation complete.");
        }

        // --- Toolbar UI Management ---
        function updateToolbarSelection() {
             document.querySelectorAll('#toolbar .tool-button').forEach(btn => btn.classList.remove('selected'));
             const selectedButton = document.getElementById(`tool-${currentTool}`);
             if (selectedButton) selectedButton.classList.add('selected');
        }
        function setupToolbar() {
             toolTypes.forEach(type => {
                const url = textureUrls[type]; const button = document.createElement('div');
                button.id = `tool-${type}`; button.classList.add('tool-button');
                button.dataset.type = type;
                if (url) button.style.backgroundImage = `url(${url})`;
                else button.style.backgroundColor = '#ff00ff';
                button.addEventListener('click', () => {
                    currentTool = type; currentToolIndex = toolTypes.indexOf(type);
                    updateToolbarSelection();
                });
                toolbar.appendChild(button);
            });
            updateToolbarSelection();
        }

        // --- Player AABB Helper ---
        function getPlayerAABB(position) {
            // AABB is defined from bottom-center up to top-center
             return new THREE.Box3(
                new THREE.Vector3(position.x - playerHalfWidth, position.y - playerHeight, position.z - playerHalfDepth),
                new THREE.Vector3(position.x + playerHalfWidth, position.y,                position.z + playerHalfDepth)
            );
        }

        // --- Collision Check Function (CHUNK-AWARE) ---
        function checkCollision(playerPos) {
             const playerAABB = getPlayerAABB(playerPos);
            const minX = Math.floor(playerAABB.min.x); const maxX = Math.floor(playerAABB.max.x);
            const minY = Math.floor(playerAABB.min.y); const maxY = Math.floor(playerAABB.max.y);
            const minZ = Math.floor(playerAABB.min.z); const maxZ = Math.floor(playerAABB.max.z);
            for (let x = minX; x <= maxX; x++) { for (let y = minY; y <= maxY; y++) { for (let z = minZ; z <= maxZ; z++) {
                const voxelData = getVoxelDataFromWorld(x, y, z);
                if (voxelData) {
                    const blockAABB = new THREE.Box3(new THREE.Vector3(x, y, z), new THREE.Vector3(x + 1, y + 1, z + 1));
                    if (playerAABB.intersectsBox(blockAABB)) return true;
                }
            }}}
            return false;
        }


        // ===============================================================
        // ===== CHICKEN ENTITY CLASS ====================================
        // ===============================================================
        class Chicken {
            constructor(posX, posY, posZ) {
                this.position = new THREE.Vector3(posX, posY + chickenRadius, posZ);
                this.velocity = new THREE.Vector3(0, 0, 0);
                this.walkDirection = new THREE.Vector3(0, 0, 1);
                this.walkTimer = Math.random() * chickenWalkCycleDuration;
                this.onGround = false;
                this.isDead = false;

                this.mesh = new THREE.Mesh(chickenGeometry, chickenMaterial);
                this.mesh.position.copy(this.position);
                this.mesh.userData.entity = this;
                this.mesh.userData.isEntity = true; // Not strictly needed now, but good practice
                scene.add(this.mesh);

                // *** Assign to initial chunk ***
                this.currentChunk = null; // Will be set below
                this.updateChunkAffiliation(true); // Force initial assignment
            }

            // *** Checks current position and updates chunk if needed ***
            updateChunkAffiliation(forceAssign = false) {
                const currentCoords = getChunkCoords(this.position.x, this.position.y, this.position.z);
                const currentKey = getChunkKey(currentCoords.x, currentCoords.y, currentCoords.z);

                if (forceAssign || !this.currentChunk || this.currentChunk.chunkKey !== currentKey) {
                    // Remove from old chunk if exists
                    if (this.currentChunk) {
                        this.currentChunk.removeEntity(this);
                    }
                    // Get new chunk (creates if necessary)
                    const newChunk = getChunk(currentCoords);
                    // Add to new chunk
                    newChunk.addEntity(this);
                    // Update internal reference
                    this.currentChunk = newChunk;
                    // console.log(`Entity moved to chunk ${newChunk.chunkKey}`);
                }
            }


            update(delta) {
                if (this.isDead) return;

                // --- Behavior: Random Walking ---
                this.walkTimer -= delta;
                if (this.walkTimer <= 0) {
                    // Pick a new random horizontal direction
                    const angle = Math.random() * Math.PI * 2;
                    this.walkDirection.set(Math.cos(angle), 0, Math.sin(angle)).normalize();
                    this.walkTimer = chickenWalkCycleDuration * (0.5 + Math.random()); // Reset timer with some variation
                }

                // --- Physics ---
                // Assume falling unless ground is detected
                this.onGround = false;
                // Apply gravity
                this.velocity.y -= gravity * delta;


                // --- Collision & Ground Check ---
                // Check block directly below the chicken's center
                const checkX = Math.floor(this.position.x);
                // Check slightly below the bottom sphere point
                const checkY = Math.floor(this.position.y - chickenRadius - 0.1);
                const checkZ = Math.floor(this.position.z);
                const voxelBelow = getVoxelDataFromWorld(checkX, checkY, checkZ);

                let targetPosY = this.position.y + this.velocity.y * delta;

                if (voxelBelow) {
                    const groundY = checkY + 1 + chickenRadius; // Top of the block + chicken radius
                    // If moving down and penetrating ground, stop at ground level
                    if (this.velocity.y <= 0 && targetPosY <= groundY) {
                        this.velocity.y = 0;
                        targetPosY = groundY;
                        this.onGround = true;
                    }
                } else {
                     // If no block below and falling, continue falling
                    this.onGround = false; // Ensure onGround is false if no voxel found
                }

                // --- Apply Horizontal Movement (only if on ground for simplicity) ---
                let targetPosX = this.position.x;
                let targetPosZ = this.position.z;

                 if (this.onGround) {
                     targetPosX += this.walkDirection.x * chickenSpeed * delta;
                     targetPosZ += this.walkDirection.z * chickenSpeed * delta;

                     // --- Basic Wall Collision ---
                     // Check if the new horizontal position is inside a block at feet level
                     const nextBlockX = Math.floor(targetPosX);
                     // Check Y level slightly above feet to avoid catching on edges when moving up slopes (though we dont have slopes yet)
                     const currentBlockY = Math.floor(this.position.y - chickenRadius + 0.1);
                     const nextBlockZ = Math.floor(targetPosZ);

                     const collisionBlock = getVoxelDataFromWorld(nextBlockX, currentBlockY, nextBlockZ);

                     if (collisionBlock) {
                         targetPosX = this.position.x; targetPosZ = this.position.z;
                         this.walkTimer = 0; // Change direction on collision
                     }
                 }

                // Update Position
                this.position.set(targetPosX, targetPosY, targetPosZ);

                // *** Check and Update Chunk Affiliation ***
                this.updateChunkAffiliation();

                // --- Death Check ---
                if (this.position.y < fallDeathY) {
                    this.isDead = true;
                    // console.log("Chicken fell out of the world.");
                }

                // --- Update Mesh Position ---
                this.mesh.position.copy(this.position);
            }

            // --- Cleanup ---
            dispose() {
                // *** Remove from current chunk before removing mesh ***
                if (this.currentChunk) {
                    this.currentChunk.removeEntity(this);
                    this.currentChunk = null; // Clear reference
                }
                if (this.mesh) {
                    scene.remove(this.mesh);
                    // Shared geometry/material, don't dispose unless last entity
                }
                this.mesh = null;
            }
        }
        // ===============================================================
        // ===== END CHICKEN CLASS =======================================
        // ===============================================================


        // --- Spawning Function ---
        function spawnInitialEntities() {
            console.log("Spawning entities...");
            const spawnAttempts = 30; // Try to spawn this many
            let spawnedCount = 0;
            const maxChickens = 10; // Maximum number to actually spawn

            for (let i = 0; i < spawnAttempts && spawnedCount < maxChickens; i++) {
                // Pick a random X/Z within the initial generation area
                const x = Math.floor(Math.random() * worldWidth - worldWidth / 2);
                const z = Math.floor(Math.random() * worldDepth - worldDepth / 2);

                // Find the ground level at this X/Z by scanning down
                let groundY = -1;
                // Start scan from a bit above the expected ground height
                for (let y = groundHeight + 5; y >= 0; y--) {
                    const voxelData = getVoxelDataFromWorld(x, y, z);
                    if (voxelData) {
                        // Found the top block, the spawn Y is one block above it
                        groundY = y + 1;
                        break;
                    }
                }

                // Only spawn if we found ground and it's a suitable block type
                if (groundY > 0) {
                    const blockBelow = getVoxelDataFromWorld(x, groundY - 1, z);
                    if(blockBelow && ['grass', 'dirt', 'sand'].includes(blockBelow.type)) {
                        // Constructor now handles adding to chunk
                        new Chicken(x + 0.5, groundY, z + 0.5);
                        spawnedCount++;
                    }
                }
            }
            console.log(`Spawned ${spawnedCount} chickens.`);
        }

        // --- Initialization Function ---
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb); // Sky blue background
            scene.fog = new THREE.Fog(0x87ceeb, 10, 90); // Fog matches background

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            // Position player slightly above the ground height
            camera.position.set(0, groundHeight + playerHeight + 0.5, 5);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: false }); // No antialiasing for blocky look
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio); // Use device resolution
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xcccccc, 0.9); // Soft ambient light
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // Simulate sunlight
            directionalLight.position.set(50, 80, 40); // Position light source
            scene.add(directionalLight);

            // Controls
            controls = new PointerLockControls(camera, document.body);
            scene.add(controls.getObject()); // Add camera holder to scene

            // Pointer Lock Listeners
            instructions.addEventListener('click', () => controls.lock());
            controls.addEventListener('lock', () => { instructions.style.display = 'none'; blocker.style.display = 'none'; });
            controls.addEventListener('unlock', () => { blocker.style.display = 'flex'; instructions.style.display = ''; });

            // Keyboard Input
             const onKeyDown = (event) => {
                 if (event.repeat) return; // Ignore holding key down repeats for single actions like jump
                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = true; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                    case 'ArrowRight': case 'KeyD': moveRight = true; break;
                    case 'Space': if (canJump) { velocity.y = jumpVelocity; canJump = false; } break;
                }
            };
             const onKeyUp = (event) => {
                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = false; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                    case 'ArrowRight': case 'KeyD': moveRight = false; break;
                }
            };
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            // Mouse Input (Block Placement/Removal)
            window.addEventListener('mousedown', (event) => {
                  if (!controls.isLocked) return;
                 const intersection = getIntersection();
                 if (!intersection) return;
                 const obj = intersection.object; const hitData = obj.userData;
                 if (!hitData || !hitData.isVoxel) return;
                 const hitCoords = {x: hitData.x, y: hitData.y, z: hitData.z};
                 const normal = intersection.face.normal.clone();
                 if (event.button === 0) { // Left Click: Place
                     const placeCoords = { x: hitCoords.x + normal.x, y: hitCoords.y + normal.y, z: hitCoords.z + normal.z };
                     const blockAABB = new THREE.Box3( new THREE.Vector3(placeCoords.x, placeCoords.y, placeCoords.z), new THREE.Vector3(placeCoords.x + 1, placeCoords.y + 1, placeCoords.z + 1) );
                     const playerAABB = getPlayerAABB(controls.getObject().position);
                     if (!playerAABB.intersectsBox(blockAABB)) { addVoxel(placeCoords.x, placeCoords.y, placeCoords.z, currentTool); }
                     else { console.log("Cannot place block inside player"); }
                 } else if (event.button === 2) { // Right Click: Remove
                    removeVoxel(hitCoords.x, hitCoords.y, hitCoords.z);
                 }
            });

            // Scroll Wheel Input (Tool Switching) 
            window.addEventListener('wheel', (event) => {
                if (!controls.isLocked) return; event.preventDefault();
                const scrollDirection = Math.sign(event.deltaY);
                currentToolIndex = (currentToolIndex + scrollDirection + toolTypes.length) % toolTypes.length;
                currentTool = toolTypes[currentToolIndex]; updateToolbarSelection();
            }, { passive: false });

            // Get References to Info Display Elements
            fpsValueSpan = document.getElementById('fpsValue');
            posXSpan = document.getElementById('posX');
            posYSpan = document.getElementById('posY');
            posZSpan = document.getElementById('posZ');
            viewYawSpan = document.getElementById('viewYaw');
            viewPitchSpan = document.getElementById('viewPitch');
            chunkCoordsSpan = document.getElementById('chunkCoords');
            activeEntitiesCountSpan = document.getElementById('activeEntitiesCount'); // Get entity count span

            // --- World Generation, Entity Spawning & UI Setup ---
            generateWorld();
            spawnInitialEntities(); // Spawn chickens AFTER world exists
            setupToolbar();

            // --- Add Face Outline to Scene ---
            scene.add(faceOutlineMesh); // Voxel face highlight mesh

            // --- Window Resize Listener ---
            window.addEventListener('resize', onWindowResize);
        }

        // --- Resize Handler ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Raycasting Function (Filter outlines and entities) ---
        function getIntersection() {
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(objects, false);
            const validIntersects = intersects.filter(intersect => intersect.object.userData.isVoxel === true);
            return validIntersects.length > 0 ? validIntersects[0] : null;
        }

        // --- Update Voxel Face Outline ---
        function updateVoxelOutline() {
              const intersection = getIntersection();
             if (intersection) {
                const blockCenter = intersection.object.position;
                const faceNormal = intersection.face.normal.clone();
                const outlinePosition = blockCenter.clone().addScaledVector(faceNormal, 0.501);
                faceOutlineMesh.position.copy(outlinePosition);
                const lookAtTarget = outlinePosition.clone().add(faceNormal);
                faceOutlineMesh.lookAt(lookAtTarget);
                faceOutlineMesh.visible = true;
             } else {
                 faceOutlineMesh.visible = false;
             }
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = Math.max(0.0001, Math.min(0.05, (time - prevTime) / 1000));
            prevTime = time;
            totalActiveEntities = 0; // Reset count each frame

            // --- Info Display Update ---
            const fps = 1 / delta;
            const playerPos = controls.getObject().position;
            const playerRot = controls.getObject().rotation;
            const yawDeg = THREE.MathUtils.radToDeg(playerRot.y);
            const pitchDeg = THREE.MathUtils.radToDeg(playerRot.x);
            const playerChunkCoords = getChunkCoords(playerPos.x, playerPos.y, playerPos.z);
            if (fpsValueSpan) fpsValueSpan.textContent = Math.round(fps);
            if (posXSpan) posXSpan.textContent = playerPos.x.toFixed(2);
            if (posYSpan) posYSpan.textContent = playerPos.y.toFixed(2);
            if (posZSpan) posZSpan.textContent = playerPos.z.toFixed(2);
            if (viewYawSpan) viewYawSpan.textContent = ((yawDeg % 360 + 360) % 360).toFixed(1);
            if (viewPitchSpan) viewPitchSpan.textContent = pitchDeg.toFixed(1);
            if (chunkCoordsSpan) chunkCoordsSpan.textContent = `${playerChunkCoords.x},${playerChunkCoords.y},${playerChunkCoords.z}`;
            // (Entity count updated later in the loop)


             if (controls.isLocked) {
                // --- Player Physics & Movement ---
                // Apply friction/damping
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                // Apply gravity
                velocity.y -= gravity * delta;

                // Calculate movement direction based on input and camera orientation
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize(); // Ensure consistent speed diagonally

                // Get camera direction projected onto the horizontal plane
                const cameraDirection = new THREE.Vector3();
                controls.getObject().getWorldDirection(cameraDirection);
                const forward = new THREE.Vector3(cameraDirection.x, 0, cameraDirection.z).normalize();
                const right = new THREE.Vector3();
                right.crossVectors(camera.up, forward).normalize(); // Right vector relative to camera yaw

                // Calculate velocity change based on input
                const currentSpeed = playerSpeed * delta;
                let velocityChangeX = 0;
                let velocityChangeZ = 0;

                if (direction.z !== 0) { // Forward/Backward movement
                    velocityChangeX += forward.x * direction.z * currentSpeed; // Note: Changed to subtract forward X
                    velocityChangeZ += forward.z * direction.z * currentSpeed; // Note: Changed to subtract forward Z
                }
                if (direction.x !== 0) { // Left/Right movement
                    // Using cross product (camera.up, forward) seems inverted? Let's try direct right calc.
                     const rightDirection = new THREE.Vector3();
                     rightDirection.crossVectors(cameraDirection, controls.getObject().up).normalize(); // Recalc right based on actual up

                     velocityChangeX += rightDirection.x * direction.x * currentSpeed; // Apply right movement
                     velocityChangeZ += rightDirection.z * direction.x * currentSpeed;
                 }


                // Apply calculated velocity changes (note:+=/-= depends on how vectors calculated)
                 velocity.x += velocityChangeX; // This seems more logical now
                velocity.z += velocityChangeZ;

                // --- Collision Detection & Resolution (Axis-by-axis) ---
                let deltaPosX = velocity.x * delta;
                let deltaPosY = velocity.y * delta;
                let deltaPosZ = velocity.z * delta;
                let tempPos = playerPos.clone(); // Temporary position for checking

                // Resolve X movement
                tempPos.x += deltaPosX;
                if (checkCollision(tempPos)) {
                    velocity.x = 0; // Stop horizontal movement in X if collision
                    deltaPosX = 0;
                }
                tempPos.x = playerPos.x; // Reset temp position X

                // Resolve Z movement
                tempPos.z += deltaPosZ;
                if (checkCollision(tempPos)) {
                    velocity.z = 0; // Stop horizontal movement in Z if collision
                    deltaPosZ = 0;
                }
                tempPos.z = playerPos.z; // Reset temp position Z

                // Resolve Y movement (Falling / Jumping)
                tempPos.y += deltaPosY;
                let isOnGround = false;
                // canJump = false; // Reset jump state each frame unless on ground detected

                if (checkCollision(tempPos)) {
                    if (velocity.y < 0) { // Falling onto something
                         // Find the highest block top surface the player is colliding with below them
                         const checkMinX = Math.floor(playerPos.x - playerHalfWidth); const checkMaxX = Math.floor(playerPos.x + playerHalfWidth);
                         const checkMinZ = Math.floor(playerPos.z - playerHalfDepth); const checkMaxZ = Math.floor(playerPos.z + playerHalfDepth);
                         const checkYBelow = Math.floor(playerPos.y - playerHeight + deltaPosY);
                         let highestGroundY = -Infinity;

                         for (let cx = checkMinX; cx <= checkMaxX; cx++) { for (let cz = checkMinZ; cz <= checkMaxZ; cz++) {
                             const voxelData = getVoxelDataFromWorld(cx, checkYBelow, cz);
                             // If voxel exists and player feet are coming down onto it
                             if (voxelData && (playerPos.y - playerHeight >= checkYBelow + 1 - 0.01)) { // Player feet are above or just touching the block top
                                 highestGroundY = Math.max(highestGroundY, checkYBelow + 1); // The Y coord of the top surface
                             }
                         }}
                         // If we found a valid ground surface below
                         if (highestGroundY > -Infinity) {
                             deltaPosY = highestGroundY - (playerPos.y - playerHeight); // Adjust deltaY to land exactly on ground
                             isOnGround = true;
                             canJump = true; // Allow jumping again
                             velocity.y = 0; // Stop downward velocity
                         } else {
                            // Collision detected but no valid ground found directly below (e.g. side collision while falling)
                             velocity.y = 0; // Stop vertical movement
                             deltaPosY = 0;
                         }
                    } else if (velocity.y > 0) { // Rising into something (jumping)
                         // Find the lowest ceiling surface the player is colliding with above them
                         const checkMinX = Math.floor(playerPos.x - playerHalfWidth); const checkMaxX = Math.floor(playerPos.x + playerHalfWidth);
                         const checkMinZ = Math.floor(playerPos.z - playerHalfDepth); const checkMaxZ = Math.floor(playerPos.z + playerHalfDepth);
                         const checkYAbove = Math.floor(playerPos.y + deltaPosY); // Y-coord of blocks to check (player's head level)
                         let lowestCeilingY = Infinity;

                          for (let cx = checkMinX; cx <= checkMaxX; cx++) { for (let cz = checkMinZ; cz <= checkMaxZ; cz++) {
                              const voxelData = getVoxelDataFromWorld(cx, checkYAbove, cz);
                              // If voxel exists and player head is moving up into it
                              if (voxelData && (playerPos.y <= checkYAbove + 0.01)) { // Player head is below or just touching the block bottom
                                  lowestCeilingY = Math.min(lowestCeilingY, checkYAbove); // The Y coord of the bottom surface
                              }
                          }}
                          // If we found a valid ceiling surface above
                          if (lowestCeilingY < Infinity) {
                              deltaPosY = lowestCeilingY - playerPos.y - 0.01; // Adjust deltaY to stop just below ceiling
                              velocity.y = 0; // Stop upward velocity
                          } else {
                              // Collision detected but no ceiling found (e.g. side collision while rising)
                              // This case is less common, usually X/Z collision handles it first.
                              velocity.y = 0; // Stop vertical movement
                              deltaPosY = 0;
                          }
                    } else { // Moving horizontally into something (velocity.y is 0)
                        // Vertical collision shouldn't happen if velocity.y is 0, X/Z checks handle this.
                        deltaPosY = 0;
                    }
                } else {
                   // No collision in Y direction, check if standing on ground just below current pos
                   const checkYDirectlyBelow = Math.floor(playerPos.y - playerHeight - 0.1); // Check slightly below feet
                   const checkMinX = Math.floor(playerPos.x - playerHalfWidth); const checkMaxX = Math.floor(playerPos.x + playerHalfWidth);
                   const checkMinZ = Math.floor(playerPos.z - playerHalfDepth); const checkMaxZ = Math.floor(playerPos.z + playerHalfDepth);
                   let groundDirectlyBelow = false;
                   for (let cx = checkMinX; cx <= checkMaxX; cx++) { for (let cz = checkMinZ; cz <= checkMaxZ; cz++) {
                       if (getVoxelDataFromWorld(cx, checkYDirectlyBelow, cz)) {
                           groundDirectlyBelow = true;
                           break;
                       }
                   }}
                   if (groundDirectlyBelow && velocity.y <= 0) { // Check velocity to ensure not moving upwards away from ground
                       isOnGround = true;
                       canJump = true;
                       // Snap to ground if slightly floating? Optional.
                       // playerPos.y = checkYDirectlyBelow + 1 + playerHeight;
                       // velocity.y = 0; // Ensure vertical velocity is zeroed if snapped
                   } else {
                       canJump = false; // Not on ground, cannot jump
                   }

                }


                // Apply Final Calculated Movement Deltas
                playerPos.x += deltaPosX;
                playerPos.y += deltaPosY;
                playerPos.z += deltaPosZ;

                // --- Prevent falling out of world ---
                if (playerPos.y < fallDeathY) { // Use the same fall death level as chickens
                    console.log("Player fell out of world, resetting position.");
                    playerPos.set(0, groundHeight + playerHeight + 5, 0); // Reset position higher up
                    velocity.set(0,0,0); // Reset velocity
                    canJump = false;
                }

                // Update voxel outline based on raycast
                updateVoxelOutline();

             } else { // Paused state
                 velocity.set(0, 0, 0); // Stop player movement when paused
                 canJump = false;
                 faceOutlineMesh.visible = false; // Hide voxel outline when paused
             }

            // =======================================================
            // ===== ENTITY UPDATE LOOP (Chunk-Based) ================
            // =======================================================
            const { x: pcx, y: pcy, z: pcz } = playerChunkCoords; // Use already calculated player chunk coords

            // Iterate through chunks in a radius around the player
            for (let cx = pcx - entityUpdateRadius; cx <= pcx + entityUpdateRadius; cx++) {
                for (let cy = pcy - entityUpdateRadius; cy <= pcy + entityUpdateRadius; cy++) { // Check Y range too
                    for (let cz = pcz - entityUpdateRadius; cz <= pcz + entityUpdateRadius; cz++) {
                        const key = getChunkKey(cx, cy, cz);
                        const chunk = world[key]; // Get chunk if it exists

                        if (chunk && chunk.entities.size > 0) {
                            // Iterate over a *copy* of the Set, as entity.update might change chunks (modifying the set)
                            const entitiesInChunk = Array.from(chunk.entities);
                             totalActiveEntities += entitiesInChunk.length; // Add to count

                            for (const entity of entitiesInChunk) {
                                // Check if the entity is *still* supposed to be in this chunk
                                // (It might have moved in the same frame by another entity's update if updates were ordered differently)
                                // This is a safety check, usually updateChunkAffiliation handles it.
                                if (entity.currentChunk === chunk) {
                                    entity.update(delta);

                                    // Check if entity died during its update
                                    if (entity.isDead) {
                                        entity.dispose(); // Dispose handles removing from chunk now
                                        // No need to explicitly remove from chunk.entities here
                                        // as dispose() does it, and we are iterating a copy.
                                    }
                                }
                            }
                        }
                    }
                }
            }
            // =======================================================

            // Update Entity Count Display
            if(activeEntitiesCountSpan) activeEntitiesCountSpan.textContent = totalActiveEntities;

            // Render the scene
            renderer.render(scene, camera);
        }

        // --- Start ---
        init();
        animate();

    </script>
</body>
</html>
